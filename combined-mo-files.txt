File: src/backend/Dao.mo
import Principal "mo:base/Principal";
import Nat32 "mo:base/Nat32";
import Debug "mo:base/Debug";
import Nat "mo:base/Nat";
import Iter "mo:base/Iter";
import HashMap "mo:base/HashMap";
import Time "mo:base/Time";
import Timer "mo:base/Timer";
import Float "mo:base/Float";
import Int "mo:base/Int";
import Buffer "mo:base/Buffer";
import Error "mo:base/Error";
import Order "mo:base/Order";
import IterTools "mo:itertools/Iter";
import CommonTypes "./Types";

module {
    public type StableData<TProposalContent> = {
        proposals : [Proposal<TProposalContent>];
        proposalDuration : Duration;
        votingThreshold : VotingThreshold;
    };

    public type VotingThreshold = {
        #percent : { percent : Percent; quorum : ?Percent };
    };

    public type Duration = {
        #days : Nat;
        #nanoseconds : Nat;
    };

    public type Percent = Nat; // 0-100

    public type Member = {
        votingPower : Nat;
        id : Principal;
    };

    public type Proposal<TProposalContent> = {
        id : Nat;
        proposer : Principal;
        timeStart : Int;
        timeEnd : Int;
        endTimerId : ?Nat;
        content : TProposalContent;
        votes : [(Principal, Vote)];
        statusLog : [ProposalStatusLogEntry];
    };

    public type ProposalStatusLogEntry = {
        #executing : {
            time : Time.Time;
        };
        #executed : {
            time : Time.Time;
        };
        #failedToExecute : {
            time : Time.Time;
            error : Text;
        };
        #rejected : {
            time : Time.Time;
        };
    };

    public type Vote = {
        value : ?Bool;
        votingPower : Nat;
    };

    type MutableProposal<TProposalContent> = {
        id : Nat;
        proposer : Principal;
        timeStart : Int;
        timeEnd : Int;
        var endTimerId : ?Nat;
        content : TProposalContent;
        votes : HashMap.HashMap<Principal, Vote>;
        statusLog : Buffer.Buffer<ProposalStatusLogEntry>;
        votingSummary : VotingSummary;
    };

    type VotingSummary = {
        var yes : Nat;
        var no : Nat;
        var notVoted : Nat;
    };

    public type AddMemberResult = {
        #ok;
        #alreadyExists;
    };

    public type CreateProposalResult = {
        #ok : Nat;
        #notAuthorized;
    };

    public type VoteResult = {
        #ok;
        #notAuthorized;
        #alreadyVoted;
        #votingClosed;
        #proposalNotFound;
    };

    public type OnExecuteResult = {
        #ok;
        #err : Text;
    };

    // TODO add validate proposal method
    public class Dao<TProposalContent>(
        data : StableData<TProposalContent>,
        onExecute : Proposal<TProposalContent> -> async* OnExecuteResult,
        onReject : Proposal<TProposalContent> -> async* (),
    ) {
        func hashNat(n : Nat) : Nat32 = Nat32.fromNat(n); // TODO

        let proposalsIter = data.proposals.vals()
        |> Iter.map<Proposal<TProposalContent>, (Nat, MutableProposal<TProposalContent>)>(
            _,
            func(proposal : Proposal<TProposalContent>) : (Nat, MutableProposal<TProposalContent>) {
                let mutableProposal = toMutableProposal(proposal);
                (
                    proposal.id,
                    mutableProposal,
                );
            },
        );

        var proposals = HashMap.fromIter<Nat, MutableProposal<TProposalContent>>(proposalsIter, 0, Nat.equal, hashNat);
        var nextProposalId = data.proposals.size(); // TODO make last proposal + 1

        var proposalDuration = data.proposalDuration;
        var votingThreshold = data.votingThreshold;

        public func resetEndTimers<system>() {
            for (proposal in proposals.vals()) {
                switch (proposal.endTimerId) {
                    case (null) ();
                    case (?id) Timer.cancelTimer(id);
                };
                proposal.endTimerId := null;
                let currentStatus = getProposalStatus(proposal.statusLog);
                if (currentStatus == #open) {
                    let proposalDurationNanoseconds = durationToNanoseconds(proposalDuration);
                    let endTimerId = createEndTimer<system>(proposal.id, proposalDurationNanoseconds);
                    proposal.endTimerId := ?endTimerId;
                };
            };
        };

        public func getProposal(id : Nat) : ?Proposal<TProposalContent> {
            let ?proposal = proposals.get(id) else return null;
            ?{
                proposal with
                endTimerId = proposal.endTimerId;
                votes = Iter.toArray(proposal.votes.entries());
                statusLog = Buffer.toArray(proposal.statusLog);
                votingSummary = {
                    yes = proposal.votingSummary.yes;
                    no = proposal.votingSummary.no;
                    notVoted = proposal.votingSummary.notVoted;
                };
            };
        };

        public func getProposals(count : Nat, offset : Nat) : CommonTypes.PagedResult<Proposal<TProposalContent>> {
            let vals = proposals.vals()
            |> Iter.map(
                _,
                func(proposal : MutableProposal<TProposalContent>) : Proposal<TProposalContent> = fromMutableProposal(proposal),
            )
            |> IterTools.sort(
                _,
                func(proposalA : Proposal<TProposalContent>, proposalB : Proposal<TProposalContent>) : Order.Order {
                    Int.compare(proposalA.timeStart, proposalB.timeStart);
                },
            )
            |> IterTools.skip(_, offset)
            |> IterTools.take(_, count)
            |> Iter.toArray(_);
            {
                data = vals;
                offset = offset;
                count = count;
            };
        };

        public func vote(proposalId : Nat, voterId : Principal, vote : Bool) : async* VoteResult {
            let ?proposal = proposals.get(proposalId) else return #proposalNotFound;
            let now = Time.now();
            let currentStatus = getProposalStatus(proposal.statusLog);
            if (proposal.timeStart > now or proposal.timeEnd < now or currentStatus != #open) {
                return #votingClosed;
            };
            let ?existingVote = proposal.votes.get(voterId) else return #notAuthorized; // Only allow members to vote who existed when the proposal was created
            if (existingVote.value != null) {
                return #alreadyVoted;
            };
            proposal.votes.put(
                voterId,
                {
                    existingVote with
                    value = ?vote;
                },
            );
            proposal.votingSummary.notVoted -= existingVote.votingPower;
            if (vote) {
                proposal.votingSummary.yes += existingVote.votingPower;
            } else {
                proposal.votingSummary.no += existingVote.votingPower;
            };
            switch (calculateVoteStatus(proposal)) {
                case (#passed) {
                    await* executeOrRejectProposal(proposal, true);
                };
                case (#rejected) {
                    await* executeOrRejectProposal(proposal, false);
                };
                case (#undetermined) ();
            };
            #ok;
        };

        public func createProposal<system>(
            proposer : Principal,
            content : TProposalContent,
            members : [Member],
        ) : CreateProposalResult {
            let now = Time.now();
            let votes = HashMap.HashMap<Principal, Vote>(0, Principal.equal, Principal.hash);
            // Take snapshot of members at the time of proposal creation
            for (member in members.vals()) {
                votes.put(
                    member.id,
                    {
                        value = null; // Not voted
                        votingPower = member.votingPower;
                    },
                );
            };
            let proposalId = nextProposalId;
            let proposalDurationNanoseconds = durationToNanoseconds(proposalDuration);
            let endTimerId = createEndTimer<system>(proposalId, proposalDurationNanoseconds);
            let proposal : MutableProposal<TProposalContent> = {
                id = proposalId;
                proposer = proposer;
                content = content;
                timeStart = now;
                timeEnd = now + proposalDurationNanoseconds;
                var endTimerId = ?endTimerId;
                votes = votes;
                statusLog = Buffer.Buffer<ProposalStatusLogEntry>(0);
                votingSummary = buildVotingSummary(votes);
            };
            proposals.put(nextProposalId, proposal);
            nextProposalId += 1;
            #ok(proposalId);
        };

        private func durationToNanoseconds(duration : Duration) : Nat {
            switch (duration) {
                case (#days(d)) d * 24 * 60 * 60 * 1_000_000_000;
                case (#nanoseconds(n)) n;
            };
        };

        private func createEndTimer<system>(
            proposalId : Nat,
            proposalDurationNanoseconds : Nat,
        ) : Nat {
            Timer.setTimer<system>(
                #nanoseconds(proposalDurationNanoseconds),
                func() : async () {
                    switch (await* onProposalEnd(proposalId)) {
                        case (#ok) ();
                        case (#alreadyEnded) {
                            Debug.print("EndTimer: Proposal already ended: " # Nat.toText(proposalId));
                        };
                    };
                },
            );
        };

        private func onProposalEnd(proposalId : Nat) : async* {
            #ok;
            #alreadyEnded;
        } {
            let ?mutableProposal = proposals.get(proposalId) else Debug.trap("Proposal not found for onProposalEnd: " # Nat.toText(proposalId));
            switch (getProposalStatus(mutableProposal.statusLog)) {
                case (#open) {
                    let passed = switch (calculateVoteStatus(mutableProposal)) {
                        case (#passed) true;
                        case (#rejected or #undetermined) false;
                    };
                    await* executeOrRejectProposal(mutableProposal, passed);
                    #ok;
                };
                case (_) #alreadyEnded;
            };
        };

        public func toStableData() : StableData<TProposalContent> {
            let proposalsArray = proposals.entries()
            |> Iter.map(
                _,
                func((_, v) : (Nat, MutableProposal<TProposalContent>)) : Proposal<TProposalContent> = fromMutableProposal<TProposalContent>(v),
            )
            |> Iter.toArray(_);

            {
                proposals = proposalsArray;
                proposalDuration = proposalDuration;
                votingThreshold = votingThreshold;
            };
        };

        private func executeOrRejectProposal(mutableProposal : MutableProposal<TProposalContent>, execute : Bool) : async* () {
            // TODO executing
            switch (mutableProposal.endTimerId) {
                case (null) ();
                case (?id) Timer.cancelTimer(id);
            };
            mutableProposal.endTimerId := null;
            let proposal = fromMutableProposal(mutableProposal);
            if (execute) {
                mutableProposal.statusLog.add(#executing({ time = Time.now() }));

                let newStatus : ProposalStatusLogEntry = try {
                    switch (await* onExecute(proposal)) {
                        case (#ok) #executed({
                            time = Time.now();
                        });
                        case (#err(e)) #failedToExecute({
                            time = Time.now();
                            error = e;
                        });
                    };
                } catch (e) {
                    #failedToExecute({
                        time = Time.now();
                        error = Error.message(e);
                    });
                };
                mutableProposal.statusLog.add(newStatus);
            } else {
                mutableProposal.statusLog.add(#rejected({ time = Time.now() }));
                await* onReject(proposal);
            };
        };

        private func calculateVoteStatus(proposal : MutableProposal<TProposalContent>) : {
            #undetermined;
            #passed;
            #rejected;
        } {
            let votedVotingPower = proposal.votingSummary.yes + proposal.votingSummary.no;
            let totalVotingPower = votedVotingPower + proposal.votingSummary.notVoted;
            switch (votingThreshold) {
                case (#percent({ percent; quorum })) {
                    let quorumThreshold = switch (quorum) {
                        case (null) 0;
                        case (?q) calculateFromPercent(q, totalVotingPower);
                    };
                    // The proposal must reach the quorum threshold in any case
                    if (votedVotingPower >= quorumThreshold) {
                        let voteThreshold = if (proposal.timeEnd >= Time.now()) {
                            // If the proposal has reached the end time, it passes if the votes are above the threshold of the VOTED voting power
                            let votedPercent = votedVotingPower / totalVotingPower;
                            calculateFromPercent(percent, votedVotingPower);
                        } else {
                            // If the proposal has not reached the end time, it passes if votes are above the threshold of the TOTAL voting power
                            calculateFromPercent(percent, totalVotingPower);
                        };
                        if (proposal.votingSummary.yes > proposal.votingSummary.no and proposal.votingSummary.yes >= voteThreshold) {
                            return #passed;
                        } else if (proposal.votingSummary.no > proposal.votingSummary.yes and proposal.votingSummary.no >= voteThreshold) {
                            return #rejected;
                        };
                    };
                };
            };
            return #undetermined;
        };

    };

    private func getProposalStatus(proposalStatusLog : Buffer.Buffer<ProposalStatusLogEntry>) : ProposalStatusLogEntry or {
        #open;
    } {
        if (proposalStatusLog.size() < 1) {
            return #open;
        };
        proposalStatusLog.get(proposalStatusLog.size() - 1);
    };

    private func fromMutableProposal<TProposalContent>(proposal : MutableProposal<TProposalContent>) : Proposal<TProposalContent> = {
        proposal with
        endTimerId = proposal.endTimerId;
        votes = Iter.toArray(proposal.votes.entries());
        statusLog = Buffer.toArray(proposal.statusLog);
        votingSummary = {
            yes = proposal.votingSummary.yes;
            no = proposal.votingSummary.no;
            notVoted = proposal.votingSummary.notVoted;
        };
    };

    private func toMutableProposal<TProposalContent>(proposal : Proposal<TProposalContent>) : MutableProposal<TProposalContent> {
        let votes = HashMap.fromIter<Principal, Vote>(
            proposal.votes.vals(),
            proposal.votes.size(),
            Principal.equal,
            Principal.hash,
        );
        {
            proposal with
            var endTimerId = proposal.endTimerId;
            votes = votes;
            statusLog = Buffer.fromArray<ProposalStatusLogEntry>(proposal.statusLog);
            votingSummary = buildVotingSummary(votes);
        };
    };

    private func calculateFromPercent(percent : Percent, total : Nat) : Nat {
        Int.abs(Float.toInt(Float.ceil((Float.fromInt(percent) / 100.0) * Float.fromInt(total))));
    };

    private func buildVotingSummary(votes : HashMap.HashMap<Principal, Vote>) : VotingSummary {
        let votingSummary = {
            var yes = 0;
            var no = 0;
            var notVoted = 0;
        };

        for (vote in votes.vals()) {
            switch (vote.value) {
                case (null) {
                    votingSummary.notVoted += vote.votingPower;
                };
                case (?true) {
                    votingSummary.yes += vote.votingPower;
                };
                case (?false) {
                    votingSummary.no += vote.votingPower;
                };
            };
        };
        votingSummary;
    };

};


File: src/backend/Types.mo
module {
    public type PagedResult<T> = {
        data : [T];
        offset : Nat;
        count : Nat;
        // isNext : Bool; // TODO
        // totalItems : ?Nat;
    };
};


File: src/backend/Util.mo
import PseudoRandomX "mo:random/PseudoRandomX";
import Blob "mo:base/Blob";
import Buffer "mo:base/Buffer";
import Iter "mo:base/Iter";
module {

    public func arrayGetSafe<T>(array : [T], index : Nat) : ?T {
        if (index >= array.size()) {
            null;
        } else {
            ?array[index];
        };
    };

    public func arrayUpdateElementSafe<T>(array : [T], index : Nat, value : T) : ?[T] {
        if (index >= array.size()) {
            null;
        } else {
            ?arrayUpdateElement(array, index, value);
        };
    };

    public func arrayUpdateElement<T>(array : [T], index : Nat, value : T) : [T] {
        let newArray = Buffer.fromArray<T>(array);
        newArray.put(index, value);
        Buffer.toArray(newArray);
    };

};


File: src/backend/league/LeagueActor.mo
import Principal "mo:base/Principal";
import IterTools "mo:itertools/Iter";
import Iter "mo:base/Iter";
import Nat "mo:base/Nat";
import Buffer "mo:base/Buffer";
import Random "mo:base/Random";
import Debug "mo:base/Debug";
import Error "mo:base/Error";
import Text "mo:base/Text";
import Bool "mo:base/Bool";
import PseudoRandomX "mo:random/PseudoRandomX";
import Types "Types";
import UsersActor "canister:users";
import Team "../models/Team";
import Season "../models/Season";
import UserTypes "../users/Types";
import Scenario "../models/Scenario";
import SeasonHandler "SeasonHandler";
import PredictionHandler "PredictionHandler";
import ScenarioHandler "ScenarioHandler";
import TeamsHandler "TeamsHandler";
import PlayersActor "canister:players";
import TeamsActor "canister:teams";
import Dao "../Dao";
import StadiumActor "canister:stadium";

actor LeagueActor : Types.LeagueActor {
    type TeamWithId = Team.TeamWithId;
    type Prng = PseudoRandomX.PseudoRandomGenerator;

    stable var stableData = {
        stadiumInitialized = false;
        benevolentDictator : Types.BenevolentDictatorState = #open;
        season : SeasonHandler.StableData = {
            seasonStatus = #notStarted;
            teamStandings = null;
            predictions = [];
        };
        predictions : PredictionHandler.StableData = {
            matchGroups = [];
        };
        scenarios : ScenarioHandler.StableData = {
            scenarios = [];
        };
        teams : TeamsHandler.StableData = {
            teams = [];
            teamsInitialized = false;
        };
        dao : Dao.StableData<Types.ProposalContent> = {
            proposalDuration = #days(3);
            proposals = [];
            votingThreshold = #percent({
                percent = 50;
                quorum = ?20;
            });
        };
    };

    private func processEffectOutcomes(effectOutcomes : [Scenario.EffectOutcome]) : async* ScenarioHandler.ProcessEffectOutcomesResult {
        let processedOutcomes = Buffer.Buffer<ScenarioHandler.EffectOutcomeData>(effectOutcomes.size());
        for (effectOutcome in Iter.fromArray(effectOutcomes)) {
            let processed = try {
                switch (effectOutcome) {
                    case (#injury(injuryEffect)) {
                        let result = await PlayersActor.applyEffects([#injury(injuryEffect)]); // TODO optimize with bulk call
                        switch (result) {
                            case (#ok) true;
                            case (#notAuthorized) false;
                        };
                    };
                    case (#entropy(entropyEffect)) {
                        teamsHandler.updateTeamEntropy(entropyEffect.teamId, entropyEffect.delta);
                        true;
                    };
                    case (#energy(e)) {
                        teamsHandler.updateTeamEnergy(e.teamId, e.delta);
                        true;
                    };
                    case (#skill(s)) {
                        let result = await PlayersActor.applyEffects([#skill(s)]); // TODO optimize with bulk call
                        switch (result) {
                            case (#ok) true;
                            case (#notAuthorized) false;
                        };
                    };
                };

            } catch (err) {
                // TODO this should have rollback and whatnot, there shouldnt be an error but im not sure how to handle
                // errors for now
                Debug.print("Failed to process team effect outcomes: " # Error.message(err));
                false;
            };
            processedOutcomes.add({
                outcome = effectOutcome;
                processed = processed;
            });
        };
        #ok(Buffer.toArray(processedOutcomes));
    };

    var stadiumInitialized = stableData.stadiumInitialized;
    var benevolentDictator : Types.BenevolentDictatorState = stableData.benevolentDictator;
    var predictionHandler = PredictionHandler.Handler(stableData.predictions);
    var teamsHandler = TeamsHandler.Handler(stableData.teams);
    var scenarioHandler = ScenarioHandler.Handler<system>(stableData.scenarios, processEffectOutcomes);

    let seasonEventHandler : SeasonHandler.EventHandler = {
        onSeasonStart = func(_ : Season.InProgressSeason) : async* () {};
        onMatchGroupSchedule = func(matchGroupId : Nat, matchGroup : Season.ScheduledMatchGroup) : async* () {
            predictionHandler.addMatchGroup(matchGroupId, matchGroup.matches.size());
        };
        onMatchGroupStart = func(matchGroupId : Nat, _ : Season.InProgressMatchGroup) : async* () {
            predictionHandler.closeMatchGroup(matchGroupId);
        };
        onMatchGroupComplete = func(_ : Nat, _ : Season.CompletedMatchGroup) : async* () {

        };
        onSeasonEnd = func(_ : SeasonHandler.EndedSeasonVariant) : async* () {
            // TODO archive vs delete
            Debug.print("Season complete, clearing season data");
            predictionHandler.clear();
            // TODO teams reset energy/entropy? or is that a scenario thing

            // TODO handle failures
            try {
                switch (await UsersActor.onSeasonEnd()) {
                    case (#ok) ();
                    case (#notAuthorized) Debug.print("League is not authorized to call users actor 'onSeasonEnd'");
                };
            } catch (err) {
                Debug.print("Failed to call UsersActor.onSeasonEnd: " # Error.message(err));
            };
            try {
                switch (await PlayersActor.onSeasonEnd()) {
                    case (#ok) ();
                    case (#notAuthorized) Debug.print("League is not authorized to call players actor 'onSeasonEnd'");
                };
            } catch (err) {
                Debug.print("Failed to call PlayersActor.onSeasonEnd: " # Error.message(err));
            };
        };
    };

    var seasonHandler = SeasonHandler.SeasonHandler<system>(stableData.season, seasonEventHandler);

    func onExecuted(proposal : Types.Proposal) : async* Dao.OnExecuteResult {
        switch (proposal.content) {
            case (#changeTeamName(c)) {
                teamsHandler.updateTeamName(c.teamId, c.name);
                #ok;
            };
        };
    };
    func onRejected(_ : Types.Proposal) : async* () {}; // TODO
    var dao = Dao.Dao(stableData.dao, onExecuted, onRejected);
    dao.resetEndTimers<system>(); // TODO move into DAO

    system func preupgrade() {
        stableData := {
            stadiumInitialized = stadiumInitialized;
            benevolentDictator = benevolentDictator;
            season = seasonHandler.toStableData();
            predictions = predictionHandler.toStableData();
            scenarios = scenarioHandler.toStableData();
            teams = teamsHandler.toStableData();
            dao = dao.toStableData();
        };
    };

    system func postupgrade() {
        stadiumInitialized := stableData.stadiumInitialized;
        benevolentDictator := stableData.benevolentDictator;
        seasonHandler := SeasonHandler.SeasonHandler<system>(stableData.season, seasonEventHandler);
        predictionHandler := PredictionHandler.Handler(stableData.predictions);
        scenarioHandler := ScenarioHandler.Handler<system>(stableData.scenarios, processEffectOutcomes);
        teamsHandler := TeamsHandler.Handler(stableData.teams);
        dao := Dao.Dao(stableData.dao, onExecuted, onRejected);
        dao.resetEndTimers<system>(); // TODO move into DAO
    };

    public shared ({ caller }) func claimBenevolentDictatorRole() : async Types.ClaimBenevolentDictatorRoleResult {
        if (benevolentDictator != #open) {
            return #notOpenToClaim;
        };
        benevolentDictator := #claimed(caller);
        #ok;
    };

    public shared ({ caller }) func setBenevolentDictatorState(state : Types.BenevolentDictatorState) : async Types.SetBenevolentDictatorStateResult {
        if (not isLeagueOrDictator(caller)) {
            return #notAuthorized;
        };
        benevolentDictator := state;
        #ok;
    };

    public query func getBenevolentDictatorState() : async Types.BenevolentDictatorState {
        benevolentDictator;
    };

    public query func getTeams() : async [TeamWithId] {
        teamsHandler.getAll();
    };

    // TODO REMOVE ALL DELETING METHODS
    public shared ({ caller }) func clearTeams() : async () {
        if (not isLeagueOrDictator(caller)) {
            Debug.trap("Not authorized to clear teams");
        };
        teamsHandler := TeamsHandler.Handler({
            teamsInitialized = stableData.teams.teamsInitialized;
            teams = [];
        });
    };

    public query func getSeasonStatus() : async Season.SeasonStatus {
        seasonHandler.seasonStatus;
    };

    public shared ({ caller }) func createProposal(request : Types.CreateProposalRequest) : async Types.CreateProposalResult {
        let members = switch (await UsersActor.getTeamOwners(#all)) {
            case (#ok(members)) members;
        };
        switch (request.content) {
            case (#changeTeamName(c)) {
                // Team is only one who can propose to change their name
                if (caller != Principal.fromActor(TeamsActor)) {
                    return #notAuthorized;
                };
            };
        };
        dao.createProposal<system>(caller, request.content, members);
    };

    public shared query func getProposal(id : Nat) : async Types.GetProposalResult {
        switch (dao.getProposal(id)) {
            case (?proposal) return #ok(proposal);
            case (null) return #proposalNotFound;
        };
    };

    public shared query func getProposals(count : Nat, offset : Nat) : async Types.GetProposalsResult {
        #ok(dao.getProposals(count, offset));
    };

    public shared ({ caller }) func voteOnProposal(request : Types.VoteOnProposalRequest) : async Types.VoteOnProposalResult {
        await* dao.vote(request.proposalId, caller, request.vote);
    };

    public query func getTeamStandings() : async Types.GetTeamStandingsResult {
        switch (seasonHandler.teamStandings) {
            case (?standings) return #ok(Buffer.toArray(standings));
            case (null) return #notFound;
        };
    };

    public query func getScenario(scenarioId : Text) : async Types.GetScenarioResult {
        switch (scenarioHandler.getScenario(scenarioId)) {
            case (null) #notFound;
            case (?scenario) {
                #ok(mapScenario(scenario));
            };
        };
    };

    public query func getScenarios() : async Types.GetScenariosResult {
        let openScenarios = scenarioHandler.getScenarios(false).vals()
        |> Iter.map(_, mapScenario)
        |> Iter.toArray(_);
        #ok(openScenarios);
    };

    public shared ({ caller }) func addScenario(scenario : Types.AddScenarioRequest) : async Types.AddScenarioResult {
        if (not isLeagueOrDictator(caller)) {
            return #notAuthorized;
        };
        Debug.print("Adding scenario: " # scenario.id);
        switch (scenarioHandler.add<system>(scenario)) {
            case (#ok) #ok;
            case (#invalid(errors)) return #invalid(errors);
        };
    };

    public shared ({ caller }) func startSeason(request : Types.StartSeasonRequest) : async Types.StartSeasonResult {
        if (not isLeagueOrDictator(caller)) {
            return #notAuthorized;
        };
        Debug.print("Starting season");
        let seedBlob = try {
            await Random.blob();
        } catch (err) {
            return #seedGenerationError(Error.message(err));
        };
        await* initStadium(); // Hack to init stadium for calling
        let stadiumId = Principal.fromActor(StadiumActor);
        let teamsArray = teamsHandler.getAll();

        let allPlayers = await PlayersActor.getAllPlayers();

        // TODO validate the scenarios are not used

        let prng = PseudoRandomX.fromBlob(seedBlob);
        await* seasonHandler.startSeason<system>(
            prng,
            stadiumId,
            request.startTime,
            request.weekDays,
            teamsArray,
            allPlayers,
        );
    };

    public shared ({ caller }) func createTeam(request : Types.CreateTeamRequest) : async Types.CreateTeamResult {
        if (not isLeagueOrDictator(caller)) {
            return #notAuthorized;
        };
        let leagueId = Principal.fromActor(LeagueActor);
        await* teamsHandler.create(leagueId, request);
    };

    public shared ({ caller }) func predictMatchOutcome(request : Types.PredictMatchOutcomeRequest) : async Types.PredictMatchOutcomeResult {
        let ?nextScheduled = seasonHandler.getNextScheduledMatchGroup() else return #predictionsClosed;
        predictionHandler.predictMatchOutcome(
            nextScheduled.matchGroupId,
            request.matchId,
            caller,
            request.winner,
        );
    };

    public shared query ({ caller }) func getMatchGroupPredictions(matchGroupId : Nat) : async Types.GetMatchGroupPredictionsResult {
        predictionHandler.getMatchGroupSummary(matchGroupId, ?caller);
    };

    public shared ({ caller }) func startMatchGroup(matchGroupId : Nat) : async Types.StartMatchGroupResult {
        if (not isLeagueOrDictator(caller)) {
            return #notAuthorized;
        };

        await* seasonHandler.startMatchGroup(matchGroupId);

    };

    public shared ({ caller }) func onMatchGroupComplete(
        request : Types.OnMatchGroupCompleteRequest
    ) : async Types.OnMatchGroupCompleteResult {
        Debug.print("On Match group complete called for: " # Nat.toText(request.id));
        if (caller != Principal.fromActor(StadiumActor)) {
            return #notAuthorized;
        };

        let prng = try {
            PseudoRandomX.fromBlob(await Random.blob());
        } catch (err) {
            return #seedGenerationError(Error.message(err));
        };

        let result = await* seasonHandler.onMatchGroupComplete(request, prng);
        // TODO handle failure
        await* awardUserPoints(request.id, request.matches);
        result;
    };

    public shared ({ caller }) func closeSeason() : async Types.CloseSeasonResult {
        if (not isLeagueOrDictator(caller)) {
            return #notAuthorized;
        };
        let result = await* seasonHandler.close();
        await* teamsHandler.onSeasonEnd();
        result;
    };

    private func awardUserPoints(
        matchGroupId : Nat,
        completedMatches : [Season.CompletedMatch],
    ) : async* () {

        // Award users points for their predictions
        let anyAwards = switch (predictionHandler.getMatchGroup(matchGroupId)) {
            case (null) false;
            case (?matchGroupPredictions) {
                let awards = Buffer.Buffer<UserTypes.AwardPointsRequest>(0);
                var i = 0;
                for (match in Iter.fromArray(completedMatches)) {
                    if (i >= matchGroupPredictions.size()) {
                        Debug.trap("Match group predictions and completed matches do not match in size. Invalid state. Matches: " # debug_show (completedMatches) # " Predictions: " # debug_show (matchGroupPredictions));
                    };
                    let matchPredictions = matchGroupPredictions[i];
                    i += 1;
                    for ((userId, teamId) in Iter.fromArray(matchPredictions)) {
                        if (teamId == match.winner) {
                            // Award points
                            awards.add({
                                userId = userId;
                                points = 10; // TODO amount?
                            });
                        };
                    };
                };
                if (awards.size() > 0) {
                    let error : ?Text = try {
                        switch (await UsersActor.awardPoints(Buffer.toArray(awards))) {
                            case (#ok) null;
                            case (#notAuthorized) ?"League is not authorized to award user points";
                        };
                    } catch (err) {
                        // TODO how to handle this?
                        ?Error.message(err);
                    };
                    switch (error) {
                        case (null) ();
                        case (?error) Debug.print("Failed to award user points: " # error);
                    };
                    true;
                } else {
                    false;
                };
            };
        };
        if (not anyAwards) {
            Debug.print("No user points to award, skipping...");
        };
    };

    private func mapScenario(scenario : Scenario.Scenario) : Types.Scenario {
        let options : [Scenario.ScenarioOption] = scenario.options
        |> Iter.fromArray(_)
        |> IterTools.mapEntries(
            _,
            func(i : Nat, option : Scenario.ScenarioOptionWithEffect) : Scenario.ScenarioOption {
                {
                    id = i;
                    title = option.title;
                    description = option.description;
                };
            },
        )
        |> Iter.toArray(_);
        {
            id = scenario.id;
            title = scenario.title;
            description = scenario.description;
            options = options;
            state = scenario.state;
        };
    };

    private func isLeagueOrDictator(id : Principal) : Bool {
        if (id == Principal.fromActor(LeagueActor)) {
            // League is admin
            return true;
        };
        switch (benevolentDictator) {
            case (#open or #disabled) false;
            case (#claimed(claimantId)) return id == claimantId;
        };
    };

    private func initStadium() : async* () {

        if (not stadiumInitialized) {
            let #ok = await StadiumActor.setLeague(Principal.fromActor(LeagueActor)) else Debug.trap("Failed to set league on stadium");
            stadiumInitialized := true;
        };
    };
};


File: src/backend/league/PredictionHandler.mo
import HashMap "mo:base/HashMap";
import Buffer "mo:base/Buffer";
import Iter "mo:base/Iter";
import Principal "mo:base/Principal";
import Nat "mo:base/Nat";
import Nat32 "mo:base/Nat32";
import Array "mo:base/Array";
import Debug "mo:base/Debug";
import Team "../models/Team";
import Types "Types";

module {
    public type StableData = {
        matchGroups : [MatchGroupPredictions];
    };

    public type MatchGroupPredictions = {
        matchGroupId : Nat;
        isOpen : Bool;
        matchPredictions : [[(Principal, Team.TeamId)]];
    };

    type MatchGroupPredictionInfo = {
        var isOpen : Bool;
        matchPredictions : Buffer.Buffer<HashMap.HashMap<Principal, Team.TeamId>>;
    };

    public class Handler(data : StableData) {
        // MatchGroupId => Match Array of UserId => TeamId votes
        public var matchGroupPredictions : HashMap.HashMap<Nat, MatchGroupPredictionInfo> = toPredictionsHashMap(data.matchGroups);

        public func toStableData() : StableData {
            let matchGroups = matchGroupPredictions.entries()
            |> Iter.map(
                _,
                func((matchGroupId, matchGroupInfo) : (Nat, MatchGroupPredictionInfo)) : MatchGroupPredictions = {
                    matchGroupId = matchGroupId;
                    isOpen = matchGroupInfo.isOpen;
                    matchPredictions = mapMatchPredictions(matchGroupInfo.matchPredictions);
                },
            )
            |> Iter.toArray(_);
            {
                matchGroups = matchGroups;
            };
        };

        // TODO archive vs delete
        public func clear() : () {
            matchGroupPredictions := HashMap.HashMap<Nat, MatchGroupPredictionInfo>(0, Nat.equal, Nat32.fromNat);
        };

        public func addMatchGroup(matchGroupId : Nat, matchCount : Nat) : () {
            let matchPredictions = Array.tabulate(matchCount, func(_ : Nat) : HashMap.HashMap<Principal, Team.TeamId> = HashMap.HashMap<Principal, Team.TeamId>(0, Principal.equal, Principal.hash));
            let matchGroupPredictionInfo : MatchGroupPredictionInfo = {
                var isOpen = true;
                matchPredictions = Buffer.fromArray(matchPredictions);
            };
            let null = matchGroupPredictions.replace(matchGroupId, matchGroupPredictionInfo) else Debug.trap("Match group predictions already exists for match group " # Nat.toText(matchGroupId));
        };

        public func closeMatchGroup(matchGroupId : Nat) : () {
            let ?matchGroupInfo = matchGroupPredictions.get(matchGroupId) else Debug.trap("Match group predictions not found for match group " # Nat.toText(matchGroupId));
            matchGroupInfo.isOpen := false;
        };

        public func predictMatchOutcome(
            matchGroupId : Nat,
            matchId : Nat,
            caller : Principal,
            prediction : ?Team.TeamId,
        ) : Types.PredictMatchOutcomeResult {
            if (Principal.isAnonymous(caller)) {
                return #identityRequired;
            };
            let ?matchGroupInfo = matchGroupPredictions.get(matchGroupId) else return #predictionsClosed;
            if (not matchGroupInfo.isOpen) {
                return #predictionsClosed;
            };
            let ?matchPredictions = matchGroupInfo.matchPredictions.getOpt(matchId) else return #matchNotFound;

            switch (prediction) {
                case (null) ignore matchPredictions.remove(caller);
                case (?winningTeamId) matchPredictions.put(caller, winningTeamId);
            };
            #ok;
        };

        public func getMatchGroup(matchGroupId : Nat) : ?[[(Principal, Team.TeamId)]] {
            let ?matchGroupInfo = matchGroupPredictions.get(matchGroupId) else return null;
            ?mapMatchPredictions(matchGroupInfo.matchPredictions);
        };

        public func getMatchGroupSummary(matchGroupId : Nat, userContext : ?Principal) : Types.GetMatchGroupPredictionsResult {
            let ?matchGroupInfo = matchGroupPredictions.get(matchGroupId) else return #notFound;
            let predictionSummaryBuffer = Buffer.Buffer<Types.MatchPredictionSummary>(matchGroupInfo.matchPredictions.size());

            for (matchPredictions in matchGroupInfo.matchPredictions.vals()) {
                let matchPredictionSummary = {
                    var team1 = 0;
                    var team2 = 0;
                    var yourVote : ?Team.TeamId = null;
                };
                for ((userId, userPrediction) in matchPredictions.entries()) {
                    switch (userPrediction) {
                        case (#team1) matchPredictionSummary.team1 += 1;
                        case (#team2) matchPredictionSummary.team2 += 1;
                    };
                    if (?userId == userContext) {
                        matchPredictionSummary.yourVote := ?userPrediction;
                    };
                };
                predictionSummaryBuffer.add({
                    team1 = matchPredictionSummary.team1;
                    team2 = matchPredictionSummary.team2;
                    yourVote = matchPredictionSummary.yourVote;
                });
            };

            #ok({
                matches = Buffer.toArray(predictionSummaryBuffer);
            });
        };
    };

    private func mapMatchPredictions(matchPredictions : Buffer.Buffer<HashMap.HashMap<Principal, Team.TeamId>>) : [[(Principal, Team.TeamId)]] {
        matchPredictions.vals()
        |> Iter.map<HashMap.HashMap<Principal, Team.TeamId>, [(Principal, Team.TeamId)]>(
            _,
            func(matchPrediction : HashMap.HashMap<Principal, Team.TeamId>) : [(Principal, Team.TeamId)] {
                matchPrediction.entries()
                |> Iter.toArray(_);
            },
        )
        |> Iter.toArray(_);
    };

    private func toPredictionsHashMap(predictions : [MatchGroupPredictions]) : HashMap.HashMap<Nat, MatchGroupPredictionInfo> {
        let hashMap = HashMap.HashMap<Nat, MatchGroupPredictionInfo>(predictions.size(), Nat.equal, Nat32.fromNat);
        for ({ matchGroupId; isOpen; matchPredictions } in Iter.fromArray(predictions)) {
            let buffer = Buffer.Buffer<HashMap.HashMap<Principal, Team.TeamId>>(matchPredictions.size());
            for (userPredictions in Iter.fromArray(matchPredictions)) {
                let userPredictionMap = HashMap.HashMap<Principal, Team.TeamId>(userPredictions.size(), Principal.equal, Principal.hash);
                for ((userId, teamId) in Iter.fromArray(userPredictions)) {
                    userPredictionMap.put(userId, teamId);
                };
                buffer.add(userPredictionMap);
            };
            let matchGroupPredictionInfo : MatchGroupPredictionInfo = {
                var isOpen = isOpen;
                matchPredictions = buffer;
            };
            hashMap.put(matchGroupId, matchGroupPredictionInfo);
        };
        hashMap;
    };
};


File: src/backend/league/ScenarioHandler.mo
import Scenario "../models/Scenario";
import HashMap "mo:base/HashMap";
import Iter "mo:base/Iter";
import Text "mo:base/Text";
import Types "Types";
import PseudoRandomX "mo:random/PseudoRandomX";
import Buffer "mo:base/Buffer";
import Debug "mo:base/Debug";
import Array "mo:base/Array";
import Float "mo:base/Float";
import Nat "mo:base/Nat";
import Trie "mo:base/Trie";
import Option "mo:base/Option";
import Nat32 "mo:base/Nat32";
import Random "mo:base/Random";
import Error "mo:base/Error";
import Timer "mo:base/Timer";
import Time "mo:base/Time";
import Int "mo:base/Int";
import TextX "mo:xtended-text/TextX";
import TeamTypes "../team/Types";
import TeamsActor "canister:teams";
import IterTools "mo:itertools/Iter";
module {
    type Prng = PseudoRandomX.PseudoRandomGenerator;

    public type StableData = {
        scenarios : [ScenarioData];
    };

    public type TeamScenarioData = {
        id : Nat;
        option : Nat;
    };

    public type AddScenarioResult = {
        #ok;
        #invalid : [Text];
    };

    public type StartScenarioResult = {
        #ok;
        #alreadyStarted;
        #notFound;
    };

    public type ProcessEffectOutcomesResult = {
        #ok : [EffectOutcomeData];
    };

    type ScenarioData = {
        id : Text;
        title : Text;
        description : Text;
        options : [Scenario.ScenarioOptionWithEffect];
        metaEffect : Scenario.MetaEffect;
        state : ScenarioState;
        startTime : Time.Time;
        endTime : Time.Time;
        teamIds : [Nat];
    };

    type ScenarioState = {
        #notStarted : {
            startTimerId : Nat;
        };
        #inProgress : {
            endTimerId : Nat;
        };
        #resolved : ScenarioStateResolved;
    };

    public type ScenarioStateResolved = {
        teamChoices : [TeamScenarioData];
        effectOutcomes : [EffectOutcomeData];
    };

    public type EffectOutcomeData = {
        processed : Bool;
        outcome : Scenario.EffectOutcome;
    };

    public class Handler<system>(data : StableData, processEffectOutcomes : (outcomes : [Scenario.EffectOutcome]) -> async* ProcessEffectOutcomesResult) {
        let scenarios : HashMap.HashMap<Text, ScenarioData> = toHashMap(data.scenarios);

        public func toStableData() : StableData {
            {
                scenarios = scenarios.vals()
                |> Iter.toArray(_);
            };
        };

        public func getScenario(id : Text) : ?Scenario.Scenario {
            do ? {
                let data = scenarios.get(id)!;
                mapScenarioDataToScenario(data);
            };
        };

        public func getScenarios(includeNotStarted : Bool) : [Scenario.Scenario] {
            scenarios.vals()
            |> Iter.filter(
                _,
                func(scenario : ScenarioData) : Bool = switch (scenario.state) {
                    case (#notStarted(_)) includeNotStarted;
                    case (#inProgress(_) or #resolved(_)) true;
                },
            )
            |> Iter.map(
                _,
                mapScenarioDataToScenario,
            )
            |> Iter.toArray(_);
        };

        public func add<system>(scenario : Types.AddScenarioRequest) : AddScenarioResult {
            switch (validateScenario(scenario)) {
                case (#ok) {};
                case (#invalid(errors)) return #invalid(errors);
            };
            if (scenarios.get(scenario.id) != null) {
                return #invalid(["Scenario with id '" #scenario.id # "' already exists"]);
            };
            let startTimerId = createStartTimer<system>(scenario.id, scenario.startTime);
            scenarios.put(
                scenario.id,
                {

                    id = scenario.id;
                    title = scenario.title;
                    description = scenario.description;
                    options = scenario.options;
                    metaEffect = scenario.metaEffect;
                    state = #notStarted({
                        startTimerId = startTimerId;
                    });
                    startTime = scenario.startTime;
                    endTime = scenario.endTime;
                    teamIds = scenario.teamIds;
                },
            );
            #ok;
        };

        private func start(scenarioId : Text) : async* StartScenarioResult {
            let ?scenario = scenarios.get(scenarioId) else return #notFound;
            switch (scenario.state) {
                case (#notStarted({ startTimerId })) {
                    Timer.cancelTimer(startTimerId);
                    ignore scenarios.replace(
                        scenarioId,
                        {
                            scenario with
                            state = #inProgress({
                                endTimerId = createEndTimer<system>(scenarioId, scenario.endTime);
                            })
                        },
                    );
                    let onNewScenarioRequest = {
                        scenarioId = scenarioId;
                        optionCount = scenario.options.size();
                    };
                    switch (await TeamsActor.onNewScenario(onNewScenarioRequest)) {
                        case (#ok) ();
                        case (#notAuthorized) Debug.print("ERROR: Not authorized to start scenario for teams");
                    };
                    #ok;
                };
                case (#inProgress(_)) #alreadyStarted;
                case (#resolved(_)) #alreadyStarted;
            };
        };

        private func end(scenarioId : Text) : async* {
            #ok;
            #scenarioNotFound;
        } {
            let prng = PseudoRandomX.fromBlob(await Random.blob());
            let ?scenario = scenarios.get(scenarioId) else return #scenarioNotFound;
            let teamScenarioData = await* buildTeamScenarioData(scenario);
            let resolvedScenarioState = resolve(
                scenarioId,
                teamScenarioData,
                prng,
            );

            let effectOutcomes = resolvedScenarioState.effectOutcomes.vals()
            |> Iter.filter(
                _,
                func(outcome : EffectOutcomeData) : Bool = not outcome.processed,
            )
            |> Iter.map(
                _,
                func(outcome : EffectOutcomeData) : Scenario.EffectOutcome = outcome.outcome,
            )
            |> Iter.toArray(_);

            // TODO how to reproccess them?
            let processedScenarioState : ScenarioStateResolved = switch (await* processEffectOutcomes(effectOutcomes)) {
                case (#ok(updatedEffectOutcomes)) {

                    // Rejoin already processed outcomes with the newly processed ones
                    let alreadyProcessedOutcomes = resolvedScenarioState.effectOutcomes.vals()
                    |> Iter.filter(
                        _,
                        func(outcome : EffectOutcomeData) : Bool = outcome.processed,
                    )
                    |> Iter.toArray(_);

                    let allProcessedOutcomes = Array.append(alreadyProcessedOutcomes, updatedEffectOutcomes);

                    {
                        resolvedScenarioState with
                        effectOutcomes = allProcessedOutcomes
                    };
                };
            };
            scenarios.put(
                scenarioId,
                {
                    scenario with
                    state = #resolved(processedScenarioState);
                },
            );
            #ok;
        };

        private func resolve(
            scenarioId : Text,
            scenarioTeams : [TeamScenarioData],
            prng : Prng,
        ) : ScenarioStateResolved {
            let ?scenario = scenarios.get(scenarioId) else Debug.trap("Scenario not found: " # scenarioId);
            resolveScenario(
                prng,
                scenario,
                scenarioTeams,
            );
        };

        private func createStartTimer<system>(scenarioId : Text, startTime : Time.Time) : Nat {
            createTimer<system>(
                startTime,
                func() : async* () {
                    Debug.print("Starting scenario with timer. Scenario id: " # scenarioId);
                    switch (await* start(scenarioId)) {
                        case (#ok) ();
                        case (#alreadyStarted) Debug.trap("Scenario already started: " # scenarioId);
                        case (#notFound) Debug.trap("Scenario not found: " # scenarioId);
                    };
                },
            );
        };

        private func createEndTimer<system>(scenarioId : Text, endTime : Time.Time) : Nat {
            createTimer<system>(
                endTime,
                func() : async* () {
                    Debug.print("Ending scenario with timer. Scenario id: " # scenarioId);
                    switch (await* end(scenarioId)) {
                        case (#ok) ();
                        case (#scenarioNotFound) Debug.trap("Scenario not found: " # scenarioId);
                    };
                },
            );
        };

        private func createTimer<system>(time : Time.Time, func_ : () -> async* ()) : Nat {
            let durationNanos = time - Time.now();
            let durationNanosNat = if (durationNanos < 0) {
                0;
            } else {
                Int.abs(durationNanos);
            };
            Timer.setTimer<system>(
                #nanoseconds(durationNanosNat),
                func() : async () {
                    await* func_();
                },
            );
        };

        private func resetTimers<system>() : () {
            for (scenario in scenarios.vals()) {
                let updatedScenario = switch (scenario.state) {
                    case (#notStarted({ startTimerId })) {
                        Timer.cancelTimer(startTimerId);
                        ?{
                            scenario with
                            state = #notStarted({
                                startTimerId = createStartTimer<system>(scenario.id, scenario.startTime);
                            });
                        };
                    };
                    case (#inProgress({ endTimerId })) {
                        Timer.cancelTimer(endTimerId);
                        ?{
                            scenario with
                            state = #inProgress({
                                endTimerId = createEndTimer<system>(scenario.id, scenario.startTime);
                            });
                        };
                    };
                    case (#resolved(_)) null;
                };
                switch (updatedScenario) {
                    case (?s) scenarios.put(scenario.id, s);
                    case (null) ();
                };
            };

        };

        ignore resetTimers<system>();
    };

    private func mapScenarioDataToScenario(data : ScenarioData) : Scenario.Scenario {
        let state : Scenario.ScenarioState = switch (data.state) {
            case (#notStarted(_)) #notStarted;
            case (#inProgress(_)) #inProgress;
            case (#resolved(resolved)) #resolved({
                resolved with
                teamChoices = resolved.teamChoices.vals()
                |> Iter.map(
                    _,
                    func(team : TeamScenarioData) : {
                        teamId : Nat;
                        option : Nat;
                    } = {
                        teamId = team.id;
                        option = team.option;
                    },
                )
                |> Iter.toArray(_);
                effectOutcomes = resolved.effectOutcomes.vals()
                |> Iter.map(
                    _,
                    func(outcome : EffectOutcomeData) : Scenario.EffectOutcome = outcome.outcome,
                )
                |> Iter.toArray(_);
            });
        };
        {
            id = data.id;
            title = data.title;
            description = data.description;
            options = data.options;
            metaEffect = data.metaEffect;
            state = state;
        };
    };

    private func buildTeamScenarioData(scenario : ScenarioData) : async* [TeamScenarioData] {
        let teamScenarioData = Buffer.Buffer<TeamScenarioData>(scenario.teamIds.size());

        let scenarioResults = try {
            await TeamsActor.getScenarioVotingResults({
                scenarioId = scenario.id;
            });
        } catch (err : Error.Error) {
            return Debug.trap("Failed to get scenario voting results: " # Error.message(err));
        };
        let teamResults = switch (scenarioResults) {
            case (#ok(o)) o;
            case (#scenarioNotFound) return Debug.trap("Scenario not found: " # scenario.id);
            case (#notAuthorized) return Debug.trap("League is not authorized to get scenario results");
        };

        for (teamId in Iter.fromArray(scenario.teamIds)) {
            let optionOrNull = IterTools.find(teamResults.teamOptions.vals(), func(o : TeamTypes.ScenarioTeamVotingResult) : Bool = o.teamId == teamId);
            let option = switch (optionOrNull) {
                case (?o) o.option;
                case (null) 0; // TODO random if no votes?
            };

            teamScenarioData.add({
                id = teamId;
                option = option;
            });
        };
        Buffer.toArray(teamScenarioData);
    };

    type ValidateScenarioResult = {
        #ok;
        #invalid : [Text];
    };

    type ValidateEffectResult = {
        #ok;
        #invalid : [Text];
    };

    type EffectContext = {
        #league;
        #team : TeamScenarioData;
    };

    public func validateScenario(scenario : Types.AddScenarioRequest) : ValidateScenarioResult {
        let errors = Buffer.Buffer<Text>(0);
        if (TextX.isEmptyOrWhitespace(scenario.id)) {
            errors.add("Scenario must have an id");
        };
        if (TextX.isEmptyOrWhitespace(scenario.title)) {
            errors.add("Scenario must have a title");
        };
        if (TextX.isEmptyOrWhitespace(scenario.description)) {
            errors.add("Scenario must have a description");
        };
        if (scenario.options.size() < 2) {
            errors.add("Scenario must have at least 2 options");
        };
        var index = 0;
        for (option in Iter.fromArray(scenario.options)) {
            if (TextX.isEmptyOrWhitespace(option.description)) {
                errors.add("Option " # Nat.toText(index) # " must have a description");
            };
            switch (validateEffect(option.effect)) {
                case (#ok) {};
                case (#invalid(effectErrors)) {
                    for (effectError in Iter.fromArray(effectErrors)) {
                        errors.add("Option " # Nat.toText(index) # " has an invalid effect: " # effectError);
                    };
                };
            };
            index += 1;
        };
        if (errors.size() > 0) {
            #invalid(Buffer.toArray(errors));
        } else {
            #ok;
        };
    };

    private func validateEffect(effect : Scenario.Effect) : ValidateEffectResult {
        let errors = Buffer.Buffer<Text>(0);
        switch (effect) {
            case (#allOf(subEffects)) {
                var index = 0;
                for (subEffect in Iter.fromArray(subEffects)) {
                    switch (validateEffect(subEffect)) {
                        case (#ok) {};
                        case (#invalid(subEffectErrors)) {
                            for (subEffectError in Iter.fromArray(subEffectErrors)) {
                                errors.add("Effect allOf has an invalid subeffect " # Nat.toText(index) # ": " # subEffectError);
                            };
                        };
                    };
                    index += 1;
                };
            };
            case (#oneOf(subEffects)) {
                var index = 0;
                for ((weight, subEffect) in Iter.fromArray(subEffects)) {
                    if (weight < 1) {
                        errors.add("Weight must be at least 1");
                    };
                    switch (validateEffect(subEffect)) {
                        case (#ok) {};
                        case (#invalid(subEffectErrors)) {
                            for (subEffectError in Iter.fromArray(subEffectErrors)) {
                                errors.add("Effect oneOf has an invalid subeffect " # Nat.toText(index) # ": " # subEffectError);
                            };
                        };
                    };
                    index += 1;
                };
            };
            case (#skill(s)) {
                // TODO
            };
            case (#energy(e)) {
                // TODO
            };
            case (#entropy(_)) {};
            case (#injury(_)) {};
            case (#noEffect) {};
        };
        #ok;
    };

    public func resolveScenario(
        prng : Prng,
        scenario : ScenarioData,
        teams : [TeamScenarioData],
    ) : ScenarioStateResolved {
        let effectOutcomes = Buffer.Buffer<Scenario.EffectOutcome>(0);
        let teamChoices = Buffer.Buffer<TeamScenarioData>(0);
        for (team in Iter.fromArray(teams)) {
            let choice = scenario.options[team.option];
            teamChoices.add({
                id = team.id;
                option = team.option;
            });
            resolveEffectInternal(
                prng,
                #team(team),
                scenario,
                choice.effect,
                effectOutcomes,
            );
        };
        switch (scenario.metaEffect) {
            case (#noEffect) ();
            case (#leagueChoice(leagueChoice)) {
                let leagueOptionIndex = getMajorityOption(prng, teams);
                let leagueOption = leagueChoice.options[leagueOptionIndex];
                resolveEffectInternal(prng, #league, scenario, leagueOption.effect, effectOutcomes);
            };
            case (#lottery(lottery)) {
                // TODO
            };
            case (#pickASide(pickASide)) {
                // TODO
            };
            case (#proportionalBid(proportionalBid)) {
                // TODO
            };
            case (#threshold(threshold)) {
                // TODO
            };
        };
        {
            teamChoices = Buffer.toArray(teamChoices);
            effectOutcomes = effectOutcomes.vals()
            |> Iter.map(
                _,
                func(outcome : Scenario.EffectOutcome) : EffectOutcomeData = {
                    processed = false;
                    outcome = outcome;
                },
            )
            |> Iter.toArray(_);
        };
    };

    public func resolveEffect(
        prng : Prng,
        context : EffectContext,
        scenario : ScenarioData,
        effect : Scenario.Effect,
    ) : [Scenario.EffectOutcome] {
        let buffer = Buffer.Buffer<Scenario.EffectOutcome>(0);
        resolveEffectInternal(prng, context, scenario, effect, buffer);
        Buffer.toArray(buffer);
    };

    private func resolveEffectInternal(
        prng : Prng,
        context : EffectContext,
        scenario : ScenarioData,
        effect : Scenario.Effect,
        outcomes : Buffer.Buffer<Scenario.EffectOutcome>,
    ) {
        switch (effect) {
            case (#allOf(subEffects)) {
                for (subEffect in Iter.fromArray(subEffects)) {
                    resolveEffectInternal(prng, context, scenario, subEffect, outcomes);
                };
            };
            case (#oneOf(subEffects)) {
                let weightedSubEffects = Array.map<(Nat, Scenario.Effect), (Scenario.Effect, Float)>(
                    subEffects,
                    func((weight, effect) : (Nat, Scenario.Effect)) : (Scenario.Effect, Float) = (effect, Float.fromInt(weight)),
                );
                let subEffect = prng.nextArrayElementWeighted(weightedSubEffects);
                resolveEffectInternal(prng, context, scenario, subEffect, outcomes);
            };
            case (#entropy(entropyEffect)) {
                outcomes.add(
                    #entropy({
                        teamId = getTeamId(entropyEffect.team, context);
                        delta = entropyEffect.delta;
                    })
                );
            };
            case (#injury(injuryEffect)) {
                outcomes.add(
                    #injury({
                        target = getTargetInstance(context, injuryEffect.target);
                        injury = injuryEffect.injury;
                    })
                );
            };
            case (#skill(s)) {
                outcomes.add(
                    #skill({
                        target = getTargetInstance(context, s.target);
                        skill = s.skill;
                        duration = s.duration;
                        delta = s.delta;
                    })
                );
            };
            case (#energy(e)) {
                let delta = switch (e.value) {
                    case (#flat(fixed)) fixed;
                };
                outcomes.add(
                    #energy({
                        teamId = getTeamId(e.team, context);
                        delta = delta;
                    })
                );
            };
            case (#noEffect) ();
        };
    };

    private func getMajorityOption(
        prng : Prng,
        teamChoices : [TeamScenarioData],
    ) : Nat {
        if (teamChoices.size() < 1) {
            Debug.trap("No team choices");
        };
        // Get the top choice(s), if there is a tie, choose randomly
        var choiceCounts = Trie.empty<Nat, Nat>();
        var maxCount = 0;
        for (teamChoice in Iter.fromArray(teamChoices)) {
            let choiceKey = {
                key = teamChoice.option;
                hash = Nat32.fromNat(teamChoice.option);
            };
            let currentCount = Option.get(Trie.get(choiceCounts, choiceKey, Nat.equal), 0);
            let newCount = currentCount + 1;
            let (newChoiceCounts, _) = Trie.put(choiceCounts, choiceKey, Nat.equal, newCount);
            choiceCounts := newChoiceCounts;
            if (newCount > maxCount) {
                maxCount := newCount;
            };
        };
        let topChoices = Buffer.Buffer<Nat>(0);
        for ((option, choiceCount) in Trie.iter(choiceCounts)) {
            if (choiceCount == maxCount) {
                topChoices.add(option);
            };
        };
        if (topChoices.size() == 1) {
            topChoices.get(0);
        } else {
            prng.nextBufferElement(topChoices);
        };

    };

    private func getTeamId(
        team : Scenario.TargetTeam,
        context : EffectContext,
    ) : Nat {
        let choosingTeam = switch (context) {
            case (#league) Debug.trap("Cannot get team id for league context");
            case (#team(team)) team;
        };
        switch (team) {
            case (#choosingTeam) choosingTeam.id;
        };
    };

    private func getTargetInstance(
        context : EffectContext,
        target : Scenario.Target,
    ) : Scenario.TargetInstance {
        switch (target) {
            case (#league) #league;
            case (#teams(teams)) {
                let teamIds = teams
                |> Iter.fromArray(_)
                |> Iter.map(
                    _,
                    func(team : Scenario.TargetTeam) : Nat = getTeamId(team, context),
                )
                |> Iter.toArray(_);
                #teams(teamIds);
            };
            case (#positions(positions)) {
                let mappedPositions = positions
                |> Iter.fromArray(_)
                |> Iter.map(
                    _,
                    func(target : Scenario.TargetPosition) : Scenario.TargetPositionInstance = {
                        teamId = getTeamId(target.teamId, context);
                        position = target.position;
                    },
                )
                |> Iter.toArray(_);
                #positions(mappedPositions);
            };
        };
    };

    private func toHashMap(scenarios : [ScenarioData]) : HashMap.HashMap<Text, ScenarioData> {
        scenarios
        |> Iter.fromArray(_)
        |> Iter.map<ScenarioData, (Text, ScenarioData)>(
            _,
            func(scenario : ScenarioData) : (Text, ScenarioData) = (scenario.id, scenario),
        )
        |> HashMap.fromIter<Text, ScenarioData>(_, scenarios.size(), Text.equal, Text.hash);

    };
};


File: src/backend/league/ScheduleBuilder.mo
import PseudoRandomX "mo:random/PseudoRandomX";
import Time "mo:base/Time";
import Iter "mo:base/Iter";
import Buffer "mo:base/Buffer";
import Debug "mo:base/Debug";
import Nat "mo:base/Nat";
import Order "mo:base/Order";
import Nat32 "mo:base/Nat32";
import Array "mo:base/Array";
import Prelude "mo:base/Prelude";
import IterTools "mo:itertools/Iter";
import DateTime "mo:datetime/DateTime";
import Season "../models/Season";
import Components "mo:datetime/Components";

module {
    type Prng = PseudoRandomX.PseudoRandomGenerator;

    public type Match = {
        team1 : Season.TeamAssignment;
        team2 : Season.TeamAssignment;
    };

    public type MatchGroup = {
        time : Time.Time;
        matches : [Match];
    };

    public type SeasonSchedule = {
        matchGroups : [MatchGroup];
    };

    public type BuildScheduleResult = {
        #ok : SeasonSchedule;
        #err : {
            #invalidArgs : Text;
        };
    };

    public func build(
        startTime : Time.Time,
        teamIds : [Nat],
        weekDays : [Components.DayOfWeek],
    ) : BuildScheduleResult {

        if (weekDays.size() == 0) {
            return #err(#invalidArgs("No week days specified"));
        };

        let teamCount = teamIds.size();
        if (teamCount == 0) {
            return #err(#invalidArgs("No teams specified"));
        };
        if (teamCount % 2 == 1) {
            return #err(#invalidArgs("Odd number of teams"));
        };

        // Round robin tournament algorithm
        var teamOrderForWeek = Buffer.fromArray<Nat>(teamIds);

        let matchUpCountPerWeek = teamCount / 2;
        let weekCount : Nat = teamCount - 1; // Round robin should be teamCount - 1 weeks

        var nextMatchDate = DateTime.fromTime(startTime);
        let firstDayOfWeek = nextMatchDate.dayOfWeek();
        if (not IterTools.any(weekDays.vals(), func(day : Components.DayOfWeek) : Bool = day == firstDayOfWeek)) {
            return #err(#invalidArgs("Start date is not on a specified week day"));
        };
        let getDayOfWeekIndex = func(day : Components.DayOfWeek) : Nat {
            switch (day) {
                case (#sunday) 0;
                case (#monday) 1;
                case (#tuesday) 2;
                case (#wednesday) 3;
                case (#thursday) 4;
                case (#friday) 5;
                case (#saturday) 6;
            };
        };

        let compareDayOfWeek = func(a : Components.DayOfWeek, b : Components.DayOfWeek) : Order.Order {
            Nat.compare(getDayOfWeekIndex(a), getDayOfWeekIndex(b));
        };
        let equalDayOfWeek = func(a : Components.DayOfWeek, b : Components.DayOfWeek) : Bool {
            compareDayOfWeek(a, b) == #equal;
        };
        let hashDayOfWeek = func(day : Components.DayOfWeek) : Nat32 {
            Nat32.fromNat(getDayOfWeekIndex(day));
        };

        let orderedDaysOfWeek = weekDays.vals()
        |> IterTools.unique<Components.DayOfWeek>(_, hashDayOfWeek, equalDayOfWeek)
        |> Iter.sort(_, compareDayOfWeek)
        |> Iter.toArray(_);

        let ?firstDayOfWeekIndex = Array.indexOf(firstDayOfWeek, orderedDaysOfWeek, equalDayOfWeek) else Prelude.unreachable();
        var dayOfWeekIndex = firstDayOfWeekIndex;
        let maxDayOfWeekIndex : Nat = orderedDaysOfWeek.size() - 1;
        let advanceOptions = {
            addWeekOnMatchingDay = true;
            resetToStartOfDay = false;
        };
        let getNextMatchDate = func(date : DateTime.DateTime) : DateTime.DateTime {
            let newDate = date.advanceToDayOfWeek(orderedDaysOfWeek[dayOfWeekIndex], advanceOptions);
            if (dayOfWeekIndex >= maxDayOfWeekIndex) {
                dayOfWeekIndex := 0;
            } else {
                dayOfWeekIndex := dayOfWeekIndex + 1;
            };
            newDate;
        };

        let matchGroups = Buffer.Buffer<MatchGroup>(weekCount);
        for (weekIndex in IterTools.range(0, weekCount)) {

            let matches : [Match] = IterTools.range(0, matchUpCountPerWeek)
            |> Iter.map(
                _,
                func(i : Nat) : Match {
                    let team1Id = teamOrderForWeek.get(i);
                    let team2Id = teamOrderForWeek.get(teamCount - 1 - i); // First plays last, second plays second last, etc.
                    {
                        team1 = #predetermined(team1Id);
                        team2 = #predetermined(team2Id);
                    };
                },
            )
            |> Iter.toArray(_);
            matchGroups.add({
                time = nextMatchDate.toTime();
                matches = matches;
            });
            nextMatchDate := getNextMatchDate(nextMatchDate);
            // Rotate order of teams
            // 1) Freeze the first team
            // 2) Bring the last team to the second position
            // 3) Rotate the rest of the teams by one position
            let firstTeamId = teamOrderForWeek.get(0);
            let lastTeamId = teamOrderForWeek.get(teamOrderForWeek.size() - 1);
            let newOrder = Buffer.Buffer<Nat>(teamCount);
            newOrder.add(firstTeamId);
            newOrder.add(lastTeamId);
            for (i in IterTools.range(1, teamCount - 1)) {
                newOrder.add(teamOrderForWeek.get(i));
            };
            teamOrderForWeek := newOrder;
        };

        let addPlayoffRound = func(matches : [Match]) {
            if (matches.size() < 1) {
                Debug.trap("No matches in playoff round");
            };
            matchGroups.add({
                time = nextMatchDate.toTime();
                matches = matches;
            });
            nextMatchDate := getNextMatchDate(nextMatchDate);
        };
        let nextPowerOfTwo = findNextPowerOfTwo(teamCount);
        let byeTeamCount : Nat = nextPowerOfTwo - teamCount; // Number of teams that get a bye in the first round

        // Split the teams up into two halves, but exclude the teams that get a bye in the first round
        let teamsInFirstRound = IterTools.range(byeTeamCount, teamCount);
        let firstRoundMatchupCount : Nat = (teamCount - byeTeamCount) / 2;
        let (firstHalfOfTeams, secondHalfOfTeams) = teamsInFirstRound
        |> Buffer.fromIter<Nat>(_)
        |> Buffer.split(_, firstRoundMatchupCount);
        // Reverse the second half to pair first - last, second - second last, etc.
        Buffer.reverse(secondHalfOfTeams);
        let firstRoundMatches = IterTools.zip(firstHalfOfTeams.vals(), secondHalfOfTeams.vals())
        |> Iter.map(
            _,
            func((team1StandingIndex, team2StandingIndex) : (Nat, Nat)) : Match {
                {
                    team1 = #seasonStandingIndex(team1StandingIndex);
                    team2 = #seasonStandingIndex(team2StandingIndex);
                };
            },
        )
        |> Iter.toArray(_);

        // First Round
        addPlayoffRound(firstRoundMatches);

        // If there are byes, then make a second round
        if (byeTeamCount > 0) {
            let byeTeams = IterTools.range(0, byeTeamCount);

            // Second round has the top teams against the winners of the first round
            // If team count is not a power of two, then some teams get a bye in the first round
            let secondRoundMatches = byeTeams
            |> IterTools.mapEntries(
                _,
                func(index : Nat, byeTeamStandingIndex : Nat) : Match {
                    {
                        team1 = #seasonStandingIndex(byeTeamStandingIndex);
                        team2 = #winnerOfMatch(index);
                    };
                },
            )
            |> Iter.toArray(_);
            addPlayoffRound(secondRoundMatches);
        };

        label l loop {
            // Loop, halving the number of matches each time, until there is only one match left
            let lastMatchCount = matchGroups.get(matchGroups.size() - 1).matches.size();
            if (lastMatchCount <= 1) {
                break l;
            };
            let nextRoundMatches = Buffer.Buffer<Match>(lastMatchCount / 2);
            for (i in IterTools.range(0, lastMatchCount / 2)) {
                nextRoundMatches.add({
                    team1 = #winnerOfMatch(i * 2);
                    team2 = #winnerOfMatch(i * 2 + 1);
                });
            };
            addPlayoffRound(Buffer.toArray(nextRoundMatches));
        };

        #ok({
            matchGroups = Buffer.toArray(matchGroups);
        });
    };

    private func findNextPowerOfTwo(number : Nat) : Nat {
        var count : Nat = 1;
        while (count < number) {
            count := count * 2;
        };
        return count;
    };
};


File: src/backend/league/SeasonHandler.mo
import Season "../models/Season";
import Types "Types";
import Team "../models/Team";
import HashMap "mo:base/HashMap";
import Buffer "mo:base/Buffer";
import Iter "mo:base/Iter";
import Nat "mo:base/Nat";
import Principal "mo:base/Principal";
import Nat32 "mo:base/Nat32";
import Trie "mo:base/Trie";
import Prelude "mo:base/Prelude";
import Time "mo:base/Time";
import Int "mo:base/Int";
import Timer "mo:base/Timer";
import Debug "mo:base/Debug";
import Error "mo:base/Error";
import Order "mo:base/Order";
import ScheduleBuilder "ScheduleBuilder";
import PseudoRandomX "mo:random/PseudoRandomX";
import PlayerTypes "../players/Types";
import StadiumTypes "../stadium/Types";
import Util "../Util";
import MatchAura "../models/MatchAura";
import IterTools "mo:itertools/Iter";
import PlayersActor "canister:players";
import Player "../models/Player";
import FieldPosition "../models/FieldPosition";
import Components "mo:datetime/Components";

module {
    type Prng = PseudoRandomX.PseudoRandomGenerator;

    public type StableData = {
        seasonStatus : Season.SeasonStatus;
        teamStandings : ?[Types.TeamStandingInfo]; // First team to last team
    };
    public type StartSeasonResult = {
        #ok;
        #alreadyStarted;
        #noStadiumsExist;
        #invalidArgs : Text;
    };

    public type EventHandler = {
        onSeasonStart : (season : Season.InProgressSeason) -> async* ();
        onMatchGroupSchedule : (matchGroupId : Nat, matchGroup : Season.ScheduledMatchGroup) -> async* ();
        onMatchGroupStart : (matchGroupId : Nat, matchGroup : Season.InProgressMatchGroup) -> async* ();
        onMatchGroupComplete : (matchGroupId : Nat, matchGroup : Season.CompletedMatchGroup) -> async* ();
        onSeasonEnd : (season : EndedSeasonVariant) -> async* ();
    };

    public type EndedSeasonVariant = {
        #incomplete : Season.InProgressSeason;
        #completed : Season.CompletedSeason;
    };

    public class SeasonHandler<system>(data : StableData, eventHandler : EventHandler) {
        public var seasonStatus : Season.SeasonStatus = data.seasonStatus;

        // First team to last team
        public var teamStandings : ?Buffer.Buffer<Types.TeamStandingInfo> = switch (data.teamStandings) {
            case (null) null;
            case (?standings) ?Buffer.fromArray(standings);
        };

        public func toStableData() : StableData {
            {
                seasonStatus = seasonStatus;
                teamStandings = switch (teamStandings) {
                    case (null) null;
                    case (?standings) ?Buffer.toArray(standings);
                };
            };
        };

        public func startSeason<system>(
            prng : Prng,
            stadiumId : Principal,
            startTime : Time.Time,
            weekDays : [Components.DayOfWeek],
            teams : [Team.TeamWithId],
            players : [Player.Player],
        ) : async* StartSeasonResult {
            switch (seasonStatus) {
                case (#notStarted) {};
                case (#starting) return #alreadyStarted;
                case (#inProgress(_)) return #alreadyStarted;
                case (#completed(completedSeason)) {
                    // TODO archive completed season?
                };
            };
            teamStandings := null;
            seasonStatus := #starting;

            let teamIdsBuffer = teams
            |> Iter.fromArray(_)
            |> Iter.map(_, func(t : Team.TeamWithId) : Nat = t.id)
            |> Buffer.fromIter<Nat>(_);

            prng.shuffleBuffer(teamIdsBuffer); // Randomize the team order

            let buildResult = ScheduleBuilder.build(
                startTime,
                Buffer.toArray(teamIdsBuffer),
                weekDays,
            );

            let schedule : ScheduleBuilder.SeasonSchedule = switch (buildResult) {
                case (#ok(schedule)) schedule;
                case (#err(#invalidArgs(err))) {
                    seasonStatus := #notStarted;
                    return #invalidArgs(err);
                };
            };

            // Save full schedule, then try to start the first match groups
            let notScheduledMatchGroups = schedule.matchGroups
            |> Iter.fromArray(_)
            |> Iter.map(
                _,
                func(mg : ScheduleBuilder.MatchGroup) : Season.InProgressSeasonMatchGroupVariant = #notScheduled({
                    time = mg.time;
                    matches = mg.matches
                    |> Iter.fromArray(_)
                    |> Iter.map(
                        _,
                        func(m : ScheduleBuilder.Match) : Season.NotScheduledMatch = {
                            team1 = m.team1;
                            team2 = m.team2;
                        },
                    )
                    |> Iter.toArray(_);
                }),
            )
            |> Iter.toArray(_);

            let teamsWithPositions = teams
            |> Iter.fromArray(_)
            |> Iter.map(
                _,
                func(t : Team.TeamWithId) : Season.TeamInfo {
                    buildTeamInitData(t, players);
                },
            )
            |> Iter.toArray(_);

            let inProgressSeason = {
                teams = teamsWithPositions;
                players = players;
                stadiumId = stadiumId;
                matchGroups = notScheduledMatchGroups;
            };

            teamStandings := null; // No standings yet
            seasonStatus := #inProgress(inProgressSeason);
            try {
                await* eventHandler.onSeasonStart(inProgressSeason);
            } catch (err) {
                Debug.print("onSeasonStart hook failed: " # Error.message(err));
                // TODO handle error
            };
            // Get first match group to open
            let #notScheduled(firstMatchGroup) = notScheduledMatchGroups[0] else Prelude.unreachable();

            await* scheduleMatchGroup<system>(
                0,
                stadiumId,
                firstMatchGroup,
                inProgressSeason,
                prng,
            );
            #ok;
        };

        public func getNextScheduledMatchGroup() : ?{
            matchGroupId : Nat;
            matchGroup : Season.ScheduledMatchGroup;
            season : Season.InProgressSeason;
        } {
            // Get current match group by finding the next scheduled one
            switch (seasonStatus) {
                case (#inProgress(inProgressSeason)) {
                    for (i in Iter.range(0, inProgressSeason.matchGroups.size() - 1)) {
                        let matchGroup = inProgressSeason.matchGroups[i];
                        switch (matchGroup) {
                            // Find first scheduled match group
                            case (#scheduled(s)) return ?{
                                matchGroupId = i;
                                matchGroup = s;
                                season = inProgressSeason;
                            };
                            // If we find a match group that is not scheduled, then there are no upcoming match groups
                            case (#notScheduled(_) or #inProgress(_)) return null;
                            // Skip completed match groups
                            case (#completed(_)) ();
                        };
                    };
                    return null;
                };
                case (_) return null;
            };
        };

        public func getMatchGroup(matchGroupId : Nat) : ?{
            matchGroupId : Nat;
            matchGroup : Season.InProgressSeasonMatchGroupVariant;
            season : {
                #inProgress : Season.InProgressSeason;
                #completed : Season.CompletedSeason;
            };
        } {
            // Get current match group by finding the next scheduled one
            switch (seasonStatus) {
                case (#notStarted or #starting) null;
                case (#inProgress(inProgressSeason)) {
                    if (matchGroupId >= inProgressSeason.matchGroups.size()) {
                        return null;
                    };
                    ?{
                        matchGroupId = matchGroupId;
                        matchGroup = inProgressSeason.matchGroups[matchGroupId];
                        season = #inProgress(inProgressSeason);
                    };
                };
                case (#completed(c)) {
                    if (matchGroupId >= c.matchGroups.size()) {
                        return null;
                    };
                    ?{
                        matchGroupId = matchGroupId;
                        matchGroup = #completed(c.matchGroups[matchGroupId]);
                        season = #completed(c);
                    };
                };
            };
        };

        public func onMatchGroupComplete<system>(
            request : Types.OnMatchGroupCompleteRequest,
            prng : Prng,
        ) : async* Types.OnMatchGroupCompleteResult {

            let #inProgress(season) = seasonStatus else return #seasonNotOpen;
            // Get current match group
            let ?matchGroup = Util.arrayGetSafe<Season.InProgressSeasonMatchGroupVariant>(
                season.matchGroups,
                request.id,
            ) else return #matchGroupNotFound;
            let inProgressMatchGroup = switch (matchGroup) {
                case (#inProgress(matchGroupState)) matchGroupState;
                case (_) return #matchGroupNotInProgress;
            };

            // Update status to completed
            let updatedMatchGroup : Season.CompletedMatchGroup = {
                time = inProgressMatchGroup.time;
                matches = request.matches;
            };

            let ?newMatchGroups = Util.arrayUpdateElementSafe<Season.InProgressSeasonMatchGroupVariant>(
                season.matchGroups,
                request.id,
                #completed(updatedMatchGroup),
            ) else return #matchGroupNotFound;

            let completedMatchGroups = Buffer.Buffer<Season.CompletedMatchGroup>(season.matchGroups.size());
            label f for (matchGroup in Iter.fromArray(newMatchGroups)) {
                switch (matchGroup) {
                    case (#completed(completedMatchGroup)) completedMatchGroups.add(completedMatchGroup);
                    case (_) break f; // Break on first incomplete match
                };
            };

            let updatedTeamStandings : Buffer.Buffer<Types.TeamStandingInfo> = calculateTeamStandings(Buffer.toArray(completedMatchGroups));

            let updatedSeason = {
                season with
                matchGroups = newMatchGroups;
            };
            teamStandings := ?updatedTeamStandings;
            seasonStatus := #inProgress(updatedSeason);
            try {
                await* eventHandler.onMatchGroupComplete(request.id, updatedMatchGroup);
            } catch (err) {
                Debug.print("onMatchGroupComplete hook failed for match group " # Nat.toText(request.id) # ". Error: " # Error.message(err));
                // TODO handle error
            };
            let errorOrNull : ?Text = try {
                switch (await PlayersActor.addMatchStats(request.id, request.playerStats)) {
                    case (#ok) null;
                    case (#notAuthorized) ?"League not authorized to award points";
                };
            } catch (err) {
                ?Error.message(err);
            };
            switch (errorOrNull) {
                case (null) ();
                case (?error) Debug.print("Failed to award user points: " # error # "\nRequest: " # debug_show (request.playerStats));
            };

            // Get next match group to schedule
            let nextMatchGroupId = request.id + 1;
            let ?nextMatchGroup = Util.arrayGetSafe<Season.InProgressSeasonMatchGroupVariant>(
                updatedSeason.matchGroups,
                nextMatchGroupId,
            ) else {
                // Season is over because cant find more match groups
                try {
                    ignore await* close(); // TODO how to not await this?
                } catch (err) {
                    Debug.print("Failed to close season: " # Error.message(err));
                };
                return #ok;
            };
            switch (nextMatchGroup) {
                case (#notScheduled(matchGroup)) {
                    // Schedule next match group
                    await* scheduleMatchGroup<system>(
                        nextMatchGroupId,
                        inProgressMatchGroup.stadiumId,
                        matchGroup,
                        updatedSeason,
                        prng,
                    );
                };
                case (_) {
                    // TODO
                    // Anything else is a bad state
                    // Print out error, but don't fail the call
                    Debug.print("Unable to schedule next match group " # Nat.toText(nextMatchGroupId) # " because it is not in the correct state: " # debug_show (nextMatchGroup));
                };
            };
            #ok;
        };

        public func close() : async* Types.CloseSeasonResult {

            if (seasonStatus == #starting) {
                // TODO how to handle this?
                seasonStatus := #notStarted;
                return #ok;
            };
            let #inProgress(inProgressSeason) = seasonStatus else return #seasonNotOpen;
            let completedMatchGroups = switch (buildCompletedMatchGroups(inProgressSeason)) {
                case (#ok(completedMatchGroups)) completedMatchGroups;
                case (#matchGroupsNotComplete(inProgressMatchGroup)) {
                    // TODO put in bad state vs delete
                    seasonStatus := #notStarted;
                    switch (inProgressMatchGroup) {
                        case (null) ();
                        case (?inProgressMatchGroup) {
                            // Cancel live match
                            let stadiumActor = actor (Principal.toText(inProgressMatchGroup.stadiumId)) : StadiumTypes.StadiumActor;
                            switch (await stadiumActor.cancelMatchGroup({ id = inProgressMatchGroup.matchGroupId })) {
                                case (#ok or #matchGroupNotFound) ();
                            };
                        };
                    };
                    await* eventHandler.onSeasonEnd(#incomplete(inProgressSeason));
                    return #ok;
                };
            };
            let finalTeamStandings = calculateTeamStandings(completedMatchGroups);
            let completedTeams = inProgressSeason.teams
            |> Iter.fromArray(_)
            |> Iter.map(
                _,
                func(t : Season.TeamInfo) : Season.CompletedSeasonTeam {
                    let ?standingIndex = finalTeamStandings.vals()
                    |> IterTools.findIndex(_, func(s : Types.TeamStandingInfo) : Bool = s.id == t.id) else Debug.trap("Team not found in standings: " # Nat.toText(t.id));
                    let standingInfo = finalTeamStandings.get(standingIndex);

                    {
                        id = t.id;
                        name = t.name;
                        logoUrl = t.logoUrl;
                        color = t.color;
                        wins = standingInfo.wins;
                        losses = standingInfo.losses;
                        totalScore = standingInfo.totalScore;
                        positions = t.positions;
                    };
                },
            )
            |> Iter.toArray(_);

            let finalMatch = completedMatchGroups[completedMatchGroups.size() - 1].matches[0];
            let (champion, runnerUp) = switch (finalMatch.winner) {
                case (#team1) (finalMatch.team1, finalMatch.team2);
                case (#team2) (finalMatch.team2, finalMatch.team1);
                case (#tie) {
                    // Break tie by their win/loss ratio
                    let getTeamStanding = func(teamId : Nat) : Nat {
                        let ?teamStanding = IterTools.findIndex(finalTeamStandings.vals(), func(s : Types.TeamStandingInfo) : Bool = s.id == teamId) else Debug.trap("Team not found in standings: " # Nat.toText(teamId));
                        teamStanding;
                    };
                    let team1Standing = getTeamStanding(finalMatch.team1.id);
                    let team2Standing = getTeamStanding(finalMatch.team2.id);
                    // TODO how to communicate why the team with the higher standing is the champion?
                    if (team1Standing > team2Standing) {
                        (finalMatch.team1, finalMatch.team2);
                    } else {
                        (finalMatch.team2, finalMatch.team1);
                    };
                };
            };

            teamStandings := ?finalTeamStandings;
            let completedSeason = {
                championTeamId = champion.id;
                runnerUpTeamId = runnerUp.id;
                teams = completedTeams;
                matchGroups = completedMatchGroups;
            };
            seasonStatus := #completed(completedSeason);
            try {
                await* eventHandler.onSeasonEnd(#completed(completedSeason));
            } catch (err) {
                Debug.print("onSeasonEnd hook failed. Error: " # Error.message(err));
                // TODO handle error
            };
            #ok;
        };

        private func resetTimers<system>() {
            switch (seasonStatus) {
                case (#notStarted or #starting) ();
                case (#inProgress(inProgressSeason)) {
                    for (i in Iter.range(0, inProgressSeason.matchGroups.size() - 1)) {
                        let matchGroup = inProgressSeason.matchGroups[i];
                        switch (matchGroup) {
                            case (#scheduled(scheduledMatchGroup)) {
                                let timerId = scheduledMatchGroup.timerId;
                                Timer.cancelTimer(timerId);
                                let newTimerId = createStartTimer<system>(i, scheduledMatchGroup.time);
                                let ?newMatchGroups = Util.arrayUpdateElementSafe<Season.InProgressSeasonMatchGroupVariant>(
                                    inProgressSeason.matchGroups,
                                    i,
                                    #scheduled({
                                        scheduledMatchGroup with
                                        timerId = newTimerId;
                                    }),
                                ) else Debug.trap("Match group not found: " # Nat.toText(i));
                                seasonStatus := #inProgress({
                                    inProgressSeason with
                                    matchGroups = newMatchGroups;
                                });
                            };
                            case (#notScheduled(_) or #inProgress(_) or #completed(_)) ();
                        };
                    };
                };
                case (#completed(_)) ();
            };
        };

        private func createStartTimer<system>(
            matchGroupId : Nat,
            startTime : Time.Time,
        ) : Timer.TimerId {
            let timeDiff = startTime - Time.now();
            Debug.print("Scheduling match group " # Nat.toText(matchGroupId) # " in " # Int.toText(timeDiff) # " nanoseconds");
            let duration = if (timeDiff <= 0) {
                // Schedule immediately
                #nanoseconds(0);
            } else {
                #nanoseconds(Int.abs(timeDiff));
            };
            Timer.setTimer<system>(
                duration,
                func() : async () {
                    let result = try {
                        await* startMatchGroup<system>(matchGroupId);
                    } catch (err) {
                        Debug.print("Match group '" # Nat.toText(matchGroupId) # "' start callback failed: " # Error.message(err));
                        return;
                    };
                    let message = switch (result) {
                        case (#ok) "Match group started";
                        case (#matchGroupNotFound) "Match group not found";
                        case (#notAuthorized) "Not authorized";
                        case (#notScheduledYet) "Match group not scheduled yet";
                        case (#alreadyStarted) "Match group already started";
                        case (#matchErrors(errors)) "Match group errors: " # debug_show (errors);
                    };
                    Debug.print("Match group '" # Nat.toText(matchGroupId) # "' start callback: " # message);
                },
            );
        };

        private func scheduleMatchGroup<system>(
            matchGroupId : Nat,
            stadiumId : Principal,
            matchGroup : Season.NotScheduledMatchGroup,
            inProgressSeason : Season.InProgressSeason,
            prng : Prng,
        ) : async* () {
            let timerId = createStartTimer<system>(matchGroupId, matchGroup.time);

            let getTeamId = func(teamAssignment : Season.TeamAssignment) : Nat {
                switch (teamAssignment) {
                    case (#predetermined(teamId)) teamId;
                    case (#seasonStandingIndex(standingIndex)) {
                        // get team based on current season standing
                        let ?standings = teamStandings else Debug.trap("Season standings not found. Match Group Id: " # Nat.toText(matchGroupId));

                        let ?teamWithStanding = standings.getOpt(standingIndex) else Debug.trap("Standing not found. Standings: " # debug_show (Buffer.toArray(standings)) # " Standing index: " # Nat.toText(standingIndex));

                        teamWithStanding.id;
                    };
                    case (#winnerOfMatch(matchId)) {
                        let previousMatchGroupId : Nat = matchGroupId - 1;
                        // get winner of match in previous match group
                        let ?previousMatchGroup = Util.arrayGetSafe<Season.InProgressSeasonMatchGroupVariant>(
                            inProgressSeason.matchGroups,
                            previousMatchGroupId,
                        ) else Debug.trap("Previous match group not found, cannot get winner of match. Match Group Id: " # Nat.toText(previousMatchGroupId));
                        let #completed(completedMatchGroup) = previousMatchGroup else Debug.trap("Previous match group not completed, cannot get winner of match. Match Group Id: " # Nat.toText(matchGroupId));
                        let ?match = Util.arrayGetSafe<Season.CompletedMatch>(
                            completedMatchGroup.matches,
                            matchId,
                        ) else Debug.trap("Previous match not found, cannot get winner of match. Match Id: " # Nat.toText(matchId));

                        if (match.winner == #team1) {
                            match.team1.id;
                        } else {
                            match.team2.id;
                        };
                    };
                };
            };

            let scheduledMatchGroup : Season.ScheduledMatchGroup = {
                time = matchGroup.time;
                timerId = timerId;
                stadiumId = stadiumId;
                matches = matchGroup.matches
                |> Iter.fromArray(_)
                |> Iter.map(
                    _,
                    func(m : Season.NotScheduledMatch) : Season.ScheduledMatch {
                        let team1Id = getTeamId(m.team1);
                        let team2Id = getTeamId(m.team2);

                        {
                            team1 = { id = team1Id };
                            team2 = { id = team2Id };
                            aura = getRandomMatchAura(prng);
                        };
                    },
                )
                |> Iter.toArray(_);
            };

            let ?newMatchGroups = Util.arrayUpdateElementSafe<Season.InProgressSeasonMatchGroupVariant>(
                inProgressSeason.matchGroups,
                matchGroupId,
                #scheduled(scheduledMatchGroup),
            ) else return Debug.trap("Match group not found: " # Nat.toText(matchGroupId));

            seasonStatus := #inProgress({
                inProgressSeason with
                matchGroups = newMatchGroups;
            });
            try {
                await* eventHandler.onMatchGroupSchedule(matchGroupId, scheduledMatchGroup);
            } catch (err) {
                Debug.print("onMatchGroupSchedule hook failed for match group " # Nat.toText(matchGroupId) # ". Error: " # Error.message(err));
                // TODO handle error
            };

        };

        private func buildCompletedMatchGroups(
            season : Season.InProgressSeason
        ) : {
            #ok : [Season.CompletedMatchGroup];
            #matchGroupsNotComplete : ?{
                matchGroupId : Nat;
                stadiumId : Principal;
            };
        } {
            let completedMatchGroups = Buffer.Buffer<Season.CompletedMatchGroup>(season.matchGroups.size());
            var matchGroupId = 0;
            for (matchGroup in Iter.fromArray(season.matchGroups)) {
                let completedMatchGroup = switch (matchGroup) {
                    case (#completed(completedMatchGroup)) completedMatchGroup;
                    case (#notScheduled(_)) return #matchGroupsNotComplete(null);
                    case (#scheduled(_)) return #matchGroupsNotComplete(null);
                    case (#inProgress(inProgressMatchGroup)) return #matchGroupsNotComplete(
                        ?{
                            matchGroupId = matchGroupId;
                            stadiumId = inProgressMatchGroup.stadiumId;
                        }
                    );
                };
                matchGroupId += 1;
                completedMatchGroups.add(completedMatchGroup);
            };
            #ok(Buffer.toArray(completedMatchGroups));
        };

        private func calculateTeamStandings(
            matchGroups : [Season.CompletedMatchGroup]
        ) : Buffer.Buffer<Types.TeamStandingInfo> {
            var teamScores = Trie.empty<Nat, Types.TeamStandingInfo>();
            let updateTeamScore = func(
                teamId : Nat,
                score : Int,
                state : { #win; #loss; #tie },
            ) : () {

                let teamKey = {
                    key = teamId;
                    hash = Nat32.fromNat(teamId);
                };
                let currentScore = switch (Trie.get(teamScores, teamKey, Nat.equal)) {
                    case (null) {
                        {
                            wins = 0;
                            losses = 0;
                            totalScore = 0;
                        };
                    };
                    case (?score) score;
                };

                let (wins, losses) = switch (state) {
                    case (#win) (currentScore.wins + 1, currentScore.losses);
                    case (#loss) (currentScore.wins, currentScore.losses + 1);
                    case (#tie) (currentScore.wins, currentScore.losses);
                };

                // Update with +1
                let (newTeamScores, _) = Trie.put<Nat, Types.TeamStandingInfo>(
                    teamScores,
                    teamKey,
                    Nat.equal,
                    {
                        id = teamId;
                        wins = wins;
                        losses = losses;
                        totalScore = currentScore.totalScore + score;
                    },
                );
                teamScores := newTeamScores;
            };

            // Populate scores
            label f1 for (matchGroup in Iter.fromArray(matchGroups)) {
                label f2 for (match in Iter.fromArray(matchGroup.matches)) {
                    let (team1State, team2State) = switch (match.winner) {
                        case (#team1) (#win, #loss);
                        case (#team2) (#loss, #win);
                        case (#tie) (#tie, #tie);
                    };
                    updateTeamScore(match.team1.id, match.team1.score, team1State);
                    updateTeamScore(match.team2.id, match.team2.score, team2State);
                };
            };
            teamScores
            |> Trie.iter(_)
            |> Iter.map(
                _,
                func((_, v) : (Nat, Types.TeamStandingInfo)) : Types.TeamStandingInfo = v,
            )
            |> IterTools.sort(
                _,
                func(a : Types.TeamStandingInfo, b : Types.TeamStandingInfo) : Order.Order {
                    if (a.wins > b.wins) {
                        #greater;
                    } else if (a.wins < b.wins) {
                        #less;
                    } else {
                        if (a.losses < b.losses) {
                            #greater;
                        } else if (a.losses > b.losses) {
                            #less;
                        } else {
                            if (a.totalScore > b.totalScore) {
                                #greater;
                            } else if (a.totalScore < b.totalScore) {
                                #less;
                            } else {
                                #equal;
                            };
                        };
                    };
                },
            )
            |> Buffer.fromIter(_);
        };

        public func startMatchGroup(
            matchGroupId : Nat
        ) : async* Types.StartMatchGroupResult {
            let #inProgress(season) = seasonStatus else return #matchGroupNotFound;

            // Get current match group
            let ?matchGroupVariant = Util.arrayGetSafe(
                season.matchGroups,
                matchGroupId,
            ) else return #matchGroupNotFound;

            let scheduledMatchGroup : Season.ScheduledMatchGroup = switch (matchGroupVariant) {
                case (#notScheduled(_)) return #notScheduledYet;
                case (#inProgress(_)) return #alreadyStarted;
                case (#completed(_)) return #alreadyStarted;
                case (#scheduled(d)) d;
            };

            let matchStartRequestBuffer = Buffer.Buffer<StadiumTypes.StartMatchRequest>(scheduledMatchGroup.matches.size());

            let teamDataMap = HashMap.HashMap<Nat, StadiumTypes.StartMatchTeam>(0, Nat.equal, Nat32.fromNat);

            let getPlayer = func(playerId : Nat32) : Player.Player {
                let ?player = season.players
                |> Iter.fromArray(_)
                |> IterTools.find(_, func(p : Player.Player) : Bool = p.id == playerId) else Debug.trap("Player not found: " # Nat32.toText(playerId));
                player;
            };
            for (team in season.teams.vals()) {
                let teamData : StadiumTypes.StartMatchTeam = {
                    team with
                    positions = {
                        pitcher = getPlayer(team.positions.pitcher);
                        firstBase = getPlayer(team.positions.firstBase);
                        secondBase = getPlayer(team.positions.secondBase);
                        thirdBase = getPlayer(team.positions.thirdBase);
                        shortStop = getPlayer(team.positions.shortStop);
                        leftField = getPlayer(team.positions.leftField);
                        centerField = getPlayer(team.positions.centerField);
                        rightField = getPlayer(team.positions.rightField);
                    };
                };
                teamDataMap.put(team.id, teamData);
            };

            for (match in Iter.fromArray(scheduledMatchGroup.matches)) {
                let ?team1Data = teamDataMap.get(match.team1.id) else Debug.trap("Team data not found: " # Nat.toText(match.team1.id));
                let ?team2Data = teamDataMap.get(match.team2.id) else Debug.trap("Team data not found: " # Nat.toText(match.team2.id));
                matchStartRequestBuffer.add({
                    team1 = team1Data;
                    team2 = team2Data;
                    aura = match.aura.aura;
                });
            };
            let startMatchGroupRequest : StadiumTypes.StartMatchGroupRequest = {
                id = matchGroupId;
                matches = Buffer.toArray(matchStartRequestBuffer);
            };
            let stadiumActor = actor (Principal.toText(scheduledMatchGroup.stadiumId)) : StadiumTypes.StadiumActor;
            try {
                switch (await stadiumActor.startMatchGroup(startMatchGroupRequest)) {
                    case (#ok) ();
                    case (#noMatchesSpecified) Debug.trap("No matches specified for match group " # Nat.toText(matchGroupId));
                };
            } catch (err) {
                Debug.trap("Failed to start match group in stadium: " # Error.message(err));
            };
            // TODO this should better handled in case of failure to start the match
            let inProgressMatches = startMatchGroupRequest.matches
            |> Iter.fromArray(_)
            |> IterTools.mapEntries(
                _,
                func(matchId : Nat, match : StadiumTypes.StartMatchRequest) : Season.InProgressMatch {
                    let mapTeam = func(
                        teamData : StadiumTypes.StartMatchTeam
                    ) : Season.InProgressTeam {
                        {
                            id = teamData.id;
                        };
                    };
                    {
                        team1 = mapTeam(match.team1);
                        team2 = mapTeam(match.team2);
                        aura = match.aura;
                    };
                },
            )
            |> Iter.toArray(_);

            let inProgressMatchGroup = {
                time = scheduledMatchGroup.time;
                stadiumId = scheduledMatchGroup.stadiumId;
                matches = inProgressMatches;
            };
            let ?newMatchGroups = Util.arrayUpdateElementSafe<Season.InProgressSeasonMatchGroupVariant>(
                season.matchGroups,
                matchGroupId,
                #inProgress(inProgressMatchGroup),
            ) else return #matchGroupNotFound;
            seasonStatus := #inProgress({
                season with
                matchGroups = newMatchGroups;
            });
            try {
                await* eventHandler.onMatchGroupStart(matchGroupId, inProgressMatchGroup);
            } catch (err) {
                Debug.print("onMatchGroupStart hook failed for match group " #Nat.toText(matchGroupId) # ". Error: " # Error.message(err));
                // TODO handle error
            };

            #ok;
        };

        ignore resetTimers<system>();
    };

    private func buildTeamInitData(
        team : Team.TeamWithId,
        allPlayers : [Player.Player],
    ) : Season.TeamInfo {

        let teamPlayers = allPlayers
        |> Iter.fromArray(_)
        |> Iter.filter(
            _,
            func(p : Player.Player) : Bool = p.teamId == team.id,
        )
        |> Iter.toArray(_);

        let getPosition = func(position : FieldPosition.FieldPosition) : Nat32 {
            let playerOrNull = teamPlayers
            |> Iter.fromArray(_)
            |> IterTools.find(_, func(p : Player.Player) : Bool = p.position == position);
            switch (playerOrNull) {
                case (null) Debug.trap("Team " # Nat.toText(team.id) # " is missing a player in position: " # debug_show (position)); // TODO
                case (?player) player.id;
            };
        };

        let pitcher = getPosition(#pitcher);
        let firstBase = getPosition(#firstBase);
        let secondBase = getPosition(#secondBase);
        let thirdBase = getPosition(#thirdBase);
        let shortStop = getPosition(#shortStop);
        let leftField = getPosition(#leftField);
        let centerField = getPosition(#centerField);
        let rightField = getPosition(#rightField);
        {
            id = team.id;
            name = team.name;
            logoUrl = team.logoUrl;
            color = team.color;
            positions = {
                pitcher = pitcher;
                firstBase = firstBase;
                secondBase = secondBase;
                thirdBase = thirdBase;
                shortStop = shortStop;
                leftField = leftField;
                centerField = centerField;
                rightField = rightField;
            };
        };
    };

    private func getRandomMatchAura(prng : Prng) : MatchAura.MatchAuraWithMetaData {
        // TODO
        let auras = Buffer.fromArray<MatchAura.MatchAura>([
            #lowGravity,
            #explodingBalls,
            #fastBallsHardHits,
            #moreBlessingsAndCurses,
            #moveBasesIn,
            #doubleOrNothing,
            #windy,
            #rainy,
            #foggy,
            #extraStrike,
        ]);
        prng.shuffleBuffer(auras);
        let aura = auras.get(0);
        {
            MatchAura.getMetaData(aura) with
            aura = aura;
        };
    };

};


File: src/backend/league/TeamsHandler.mo
import Team "../models/Team";
import HashMap "mo:base/HashMap";
import Principal "mo:base/Principal";
import Iter "mo:base/Iter";
import Error "mo:base/Error";
import Debug "mo:base/Debug";
import Int "mo:base/Int";
import Nat "mo:base/Nat";
import Nat32 "mo:base/Nat32";
import Types "Types";
import IterTools "mo:itertools/Iter";
import TeamsActor "canister:teams";
import PlayersActor "canister:players";

module {

    public type StableData = {
        teams : [Team.TeamWithId];
        teamsInitialized : Bool;
    };
    public class Handler(data : StableData) {
        var teams : HashMap.HashMap<Nat, Team.Team> = toTeamHashMap(data.teams);
        var teamsInitialized = data.teamsInitialized;

        public func toStableData() : StableData {
            let teams = getAll();
            return {
                teams = teams;
                teamsInitialized = teamsInitialized;
            };
        };

        public func getAll() : [Team.TeamWithId] {
            teams.entries()
            |> Iter.map(
                _,
                func((k, v) : (Nat, Team.Team)) : Team.TeamWithId = {
                    v with
                    id = k;
                },
            )
            |> Iter.toArray(_);
        };

        public func updateTeamName(teamId : Nat, newName : Text) : () {
            let ?team = teams.get(teamId) else Debug.trap("Team not found: " # Nat.toText(teamId));
            let newTeam : Team.Team = {
                team with
                name = newName;
            };
            teams.put(teamId, newTeam);
        };

        public func updateTeamEnergy(teamId : Nat, delta : Int) : () {
            let ?team = teams.get(teamId) else Debug.trap("Team not found: " # Nat.toText(teamId));
            let newTeam : Team.Team = {
                team with
                energy = team.energy + delta;
            };
            teams.put(teamId, newTeam);
        };

        public func updateTeamEntropy(teamId : Nat, delta : Int) : () {
            let ?team = teams.get(teamId) else Debug.trap("Team not found: " # Nat.toText(teamId));
            let newEntropyInt : Int = team.entropy + delta;
            let newEntropyNat : Nat = if (newEntropyInt <= 0) {
                // Entropy cant be negative
                0;
            } else {
                Int.abs(newEntropyInt);
            };
            let newTeam : Team.Team = {
                team with
                entropy = newEntropyNat;
            };
            teams.put(teamId, newTeam);
        };

        public func create(
            leagueId : Principal, // TODO this should be part of the data, but we don't have a way to pass it in yet
            request : Types.CreateTeamRequest,
        ) : async* Types.CreateTeamResult {
            let nameAlreadyTaken = teams.entries()
            |> IterTools.any(
                _,
                func((_, v) : (Nat, Team.Team)) : Bool = v.name == request.name,
            );

            if (nameAlreadyTaken) {
                return #nameTaken;
            };
            if (not teamsInitialized) {
                let #ok = await TeamsActor.setLeague(leagueId) else Debug.trap("Failed to set league on teams actor");
                teamsInitialized := true;
            };
            let createTeamResult = try {
                await TeamsActor.createTeam(request);
            } catch (err) {
                return #teamsCallError(Error.message(err));
            };
            let teamInfo = switch (createTeamResult) {
                case (#ok(teamInfo)) teamInfo;
                case (#notAuthorized) return #notAuthorized;
            };
            let team : Team.Team = {
                name = request.name;
                logoUrl = request.logoUrl;
                motto = request.motto;
                description = request.description;
                entropy = 0; // TODO
                energy = 0;
                color = request.color;
            };
            teams.put(teamInfo.id, team);

            let populateResult = try {
                await PlayersActor.populateTeamRoster(teamInfo.id);
            } catch (err) {
                return #populateTeamRosterCallError(Error.message(err));
            };
            switch (populateResult) {
                case (#ok(_)) {};
                case (#notAuthorized) {
                    Debug.print("Error populating team roster: League is not authorized to populate team roster for team: " # Nat.toText(teamInfo.id));
                };
                case (#missingFluff) {
                    Debug.print("Error populating team roster: No unused player fluff available");
                };
            };
            return #ok(teamInfo.id);
        };

        public func onSeasonEnd() : async* () {
            try {
                switch (await TeamsActor.onSeasonEnd()) {
                    case (#ok) ();
                    case (#notAuthorized) Debug.print("Error: League is not authorized to notify team of season completion");
                };
            } catch (err) {
                Debug.print("Failed to notify team of season completion: " # Error.message(err));
            };
        };
    };

    private func toTeamHashMap(teams : [Team.TeamWithId]) : HashMap.HashMap<Nat, Team.Team> {
        var result = HashMap.HashMap<Nat, Team.Team>(0, Nat.equal, Nat32.fromNat);
        for (team in Iter.fromArray(teams)) {
            result.put(team.id, team);
        };
        return result;
    };
};


File: src/backend/league/Types.mo
import Time "mo:base/Time";
import Nat "mo:base/Nat";
import Player "../models/Player";
import Team "../models/Team";
import Season "../models/Season";
import Scenario "../models/Scenario";
import Dao "../Dao";
import CommonTypes "../Types";
import Components "mo:datetime/Components";

module {
    public type LeagueActor = actor {
        getTeams : query () -> async [Team.TeamWithId];
        getSeasonStatus : query () -> async Season.SeasonStatus;
        getTeamStandings : query () -> async GetTeamStandingsResult;
        startSeason : (request : StartSeasonRequest) -> async StartSeasonResult;
        closeSeason : () -> async CloseSeasonResult;
        createTeam : (request : CreateTeamRequest) -> async CreateTeamResult;
        predictMatchOutcome : (request : PredictMatchOutcomeRequest) -> async PredictMatchOutcomeResult;
        getMatchGroupPredictions : query (matchGroupId : Nat) -> async GetMatchGroupPredictionsResult;
        startMatchGroup : (id : Nat) -> async StartMatchGroupResult;
        onMatchGroupComplete : (request : OnMatchGroupCompleteRequest) -> async OnMatchGroupCompleteResult;

        createProposal : (request : CreateProposalRequest) -> async CreateProposalResult;
        getProposal : query (Nat) -> async GetProposalResult;
        getProposals : query (count : Nat, offset : Nat) -> async GetProposalsResult;
        getScenario : query (Text) -> async GetScenarioResult;
        getScenarios : query () -> async GetScenariosResult;
        voteOnProposal : VoteOnProposalRequest -> async VoteOnProposalResult;
        clearTeams : () -> async (); // TODO remove

        claimBenevolentDictatorRole : () -> async ClaimBenevolentDictatorRoleResult;
        setBenevolentDictatorState : (state : BenevolentDictatorState) -> async SetBenevolentDictatorStateResult;
        getBenevolentDictatorState : query () -> async BenevolentDictatorState;
    };

    public type ClaimBenevolentDictatorRoleResult = {
        #ok;
        #notOpenToClaim;
    };

    public type SetBenevolentDictatorStateResult = {
        #ok;
        #notAuthorized;
    };

    public type GetProposalResult = {
        #ok : Proposal;
        #proposalNotFound;
    };

    public type GetProposalsResult = {
        #ok : CommonTypes.PagedResult<Proposal>;
    };

    public type Proposal = Dao.Proposal<ProposalContent>;

    public type ProposalContent = {
        #changeTeamName : {
            teamId : Nat;
            name : Text;
        };
    };

    public type VoteOnProposalRequest = {
        proposalId : Nat;
        vote : Bool;
    };

    public type VoteOnProposalResult = {
        #ok;
        #notAuthorized;
        #proposalNotFound;
        #alreadyVoted;
        #votingClosed;
    };

    public type CreateProposalRequest = {
        content : ProposalContent;
    };

    public type CreateProposalResult = {
        #ok : Nat;
        #notAuthorized;
    };

    public type GetScenarioResult = {
        #ok : Scenario;
        #notFound;
        #notStarted;
    };

    public type GetScenariosResult = {
        #ok : [Scenario];
    };

    public type ScenarioStateResolved = {
        teamChoices : [{
            teamId : Nat;
            option : Nat;
        }];
    };

    public type Scenario = {
        id : Text;
        title : Text;
        description : Text;
        options : [Scenario.ScenarioOption];
        state : {
            #notStarted;
            #inProgress;
            #resolved : ScenarioStateResolved;
        };

    };

    public type BenevolentDictatorState = {
        #open;
        #claimed : Principal;
        #disabled;
    };

    public type TeamStandingInfo = {
        id : Nat;
        wins : Nat;
        losses : Nat;
        totalScore : Int;
    };

    public type GetTeamStandingsResult = {
        #ok : [TeamStandingInfo];
        #notFound;
    };

    public type ProcessEffectOutcomesRequest = {
        outcomes : [Scenario.EffectOutcome];
    };

    public type ProcessEffectOutcomesResult = {
        #ok;
        #notAuthorized;
        #seasonNotInProgress;
    };

    public type GetMatchGroupPredictionsResult = {
        #ok : MatchGroupPredictionSummary;
        #notFound;
    };

    public type MatchGroupPredictionSummary = {
        matches : [MatchPredictionSummary];
    };

    public type MatchPredictionSummary = {
        team1 : Nat;
        team2 : Nat;
        yourVote : ?Team.TeamId;
    };

    public type PredictMatchOutcomeRequest = {
        matchId : Nat;
        winner : ?Team.TeamId;
    };

    public type PredictMatchOutcomeResult = {
        #ok;
        #matchGroupNotFound;
        #matchNotFound;
        #predictionsClosed;
        #identityRequired;
    };

    // On start
    public type StartMatchGroupResult = {
        #ok;
        #matchGroupNotFound;
        #notAuthorized;
        #notScheduledYet;
        #alreadyStarted;
        #matchErrors : [{
            matchId : Nat;
            error : StartMatchError;
        }];
    };

    public type StartMatchError = {
        #notEnoughPlayers : Team.TeamIdOrBoth;
    };

    // Start season
    public type StartSeasonRequest = {
        startTime : Time.Time;
        weekDays : [Components.DayOfWeek];
    };

    public type AddScenarioRequest = {
        id : Text;
        startTime : Time.Time;
        endTime : Time.Time;
        title : Text;
        description : Text;
        options : [Scenario.ScenarioOptionWithEffect];
        metaEffect : Scenario.MetaEffect;
        teamIds : [Nat];
    };

    public type AddScenarioResult = {
        #ok;
        #invalid : [Text];
        #notAuthorized;
    };

    public type StartSeasonResult = {
        #ok;
        #alreadyStarted;
        #idTaken;
        #noStadiumsExist;
        #seedGenerationError : Text;
        #invalidArgs : Text;
        #notAuthorized;
    };

    public type CloseSeasonResult = {
        #ok;
        #notAuthorized;
        #seasonNotOpen;
    };

    // On complete

    public type OnMatchGroupCompleteRequest = {
        id : Nat;
        matches : [Season.CompletedMatch];
        playerStats : [Player.PlayerMatchStatsWithId];
    };

    public type FailedMatchResult = {
        message : Text;
    };

    public type OnMatchGroupCompleteResult = {
        #ok;
        #seasonNotOpen;
        #matchGroupNotFound;
        #matchGroupNotInProgress;
        #seedGenerationError : Text;
        #notAuthorized;
    };

    // Create Team

    public type CreateTeamRequest = {
        name : Text;
        logoUrl : Text;
        motto : Text;
        description : Text;
        color : (Nat8, Nat8, Nat8);
    };

    public type CreateTeamResult = {
        #ok : Nat;
        #nameTaken;
        #noStadiumsExist;
        #teamsCallError : Text;
        #notAuthorized;
        #populateTeamRosterCallError : Text;
    };
};


File: src/backend/models/Base.mo
import Hash "mo:base/Hash";
module {

    public type Base = {
        #firstBase;
        #secondBase;
        #thirdBase;
        #homeBase;
    };

    public func equalBase(a : Base, b : Base) : Bool {
        a == b;
    };

    public func hashBase(location : Base) : Hash.Hash {
        switch (location) {
            case (#homeBase) 0;
            case (#firstBase) 1;
            case (#secondBase) 2;
            case (#thirdBase) 3;
        };
    };
};


File: src/backend/models/FieldPosition.mo
import Hash "mo:base/Hash";

module {

    public type FieldPosition = {
        #firstBase;
        #secondBase;
        #thirdBase;
        #shortStop;
        #leftField;
        #centerField;
        #rightField;
        #pitcher;
    };

    public let allPositions : [FieldPosition] = [
        #pitcher,
        #firstBase,
        #secondBase,
        #thirdBase,
        #shortStop,
        #leftField,
        #centerField,
        #rightField,
    ];

    public type TeamPositions = {
        firstBase : Nat32;
        secondBase : Nat32;
        thirdBase : Nat32;
        shortStop : Nat32;
        pitcher : Nat32;
        leftField : Nat32;
        centerField : Nat32;
        rightField : Nat32;
    };

    public func getTeamPosition(poistions : TeamPositions, position : FieldPosition) : Nat32 {
        switch (position) {
            case (#firstBase) poistions.firstBase;
            case (#secondBase) poistions.secondBase;
            case (#thirdBase) poistions.thirdBase;
            case (#shortStop) poistions.shortStop;
            case (#leftField) poistions.leftField;
            case (#centerField) poistions.centerField;
            case (#rightField) poistions.rightField;
            case (#pitcher) poistions.pitcher;
        };
    };

    public func equal(a : FieldPosition, b : FieldPosition) : Bool {
        a == b;
    };

    public func hash(position : FieldPosition) : Hash.Hash {
        switch (position) {
            case (#firstBase) 0;
            case (#secondBase) 1;
            case (#thirdBase) 2;
            case (#pitcher) 3;
            case (#shortStop) 4;
            case (#leftField) 5;
            case (#centerField) 6;
            case (#rightField) 7;
        };
    };
};


File: src/backend/models/Hook.mo
import StadiumTypes "../stadium/Types";
import Buffer "mo:base/Buffer";
import Debug "mo:base/Debug";
import Trie "mo:base/Trie";
import Iter "mo:base/Iter";
import FieldPosition "FieldPosition";
import IterTools "mo:itertools/Iter";
import Skill "Skill";
import PseudoRandomX "mo:random/PseudoRandomX";
import Player "Player";
import Team "Team";
import MutableState "MutableState";

module {

    type Prng = PseudoRandomX.PseudoRandomGenerator;

    public type HookRequest<T> = {
        context : T;
        prng : Prng;
        state : MutableState.MutableMatchState;
    };

    public type HookResult<TContext> = {
        updatedContext : TContext;
    };

    public type CompiledHooks = {
        matchStart : Hook<()>;
        matchEnd : Hook<()>;
        roundStart : Hook<()>;
        roundEnd : Hook<()>;
        onDodge : Hook<SkillTestContext>;
        onPitch : Hook<SkillTestContext>;
        onSwing : Hook<SkillTestContext>;
        onHit : Hook<SkillTestContext>;
        onCatch : Hook<SkillTestContext>;
    };

    public type Hook<T> = (HookRequest<T>) -> HookResult<T>;

    public type SkillTestContext = {
        result : SkillTestResult;
        playerId : Player.PlayerId;
        skill : Skill.Skill;
    };

    public type SkillTestResult = {
        value : Int;
        crit : Bool;
    };

};


File: src/backend/models/MatchAura.mo
module {

    public type MatchAura = {
        #lowGravity;
        #explodingBalls;
        #fastBallsHardHits;
        #moreBlessingsAndCurses;
        #moveBasesIn;
        #doubleOrNothing;
        #windy;
        #rainy;
        #foggy;
        #extraStrike;
    };

    public type MatchAuraMetaData = {
        name : Text;
        description : Text;
    };

    public type MatchAuraWithMetaData = MatchAuraMetaData and {
        aura : MatchAura;
    };

    public func hash(aura : MatchAura) : Nat32 = switch (aura) {
        case (#lowGravity) 0;
        case (#explodingBalls) 1;
        case (#fastBallsHardHits) 2;
        case (#moreBlessingsAndCurses) 3;
        case (#moveBasesIn) 4;
        case (#doubleOrNothing) 5;
        case (#windy) 6;
        case (#rainy) 7;
        case (#foggy) 8;
        case (#extraStrike) 9;
    };

    public func equal(a : MatchAura, b : MatchAura) : Bool = a == b;

    public func getMetaData(aura : MatchAura) : MatchAuraMetaData {
        switch (aura) {
            // Initial config change
            // AND? on hit event?
            case (#lowGravity) {
                {
                    name = "Low Gravity";
                    description = "Balls fly farther but player speed is lowered.";
                };
            };
            // On hit event
            case (#explodingBalls) {
                {
                    name = "Exploding Balls";
                    description = "Balls have a chance to explode on contact with the bat.";
                };
            };
            // On hit event
            case (#fastBallsHardHits) {
                {
                    name = "Fast Balls, Hard Hits";
                    description = "Balls are faster and fly farther when hit by the bat.";
                };
            };
            // On blessing check or initial config change?
            case (#moreBlessingsAndCurses) {
                {
                    name = "More Blessings And Curses";
                    description = "Blessings and curses are more common.";
                };
            };
            // On run event? easier to make it to base?
            case (#moveBasesIn) {
                {
                    name = "Move Bases In";
                    description = "Bases are closer together.";
                };
            };
            // On score event
            // On strike event
            case (#doubleOrNothing) {
                {
                    name = "Double Or Nothing";
                    description = "Runs count for double points, but strikeouts lose points.";
                };
            };
            // On swing event? throw event?
            case (#windy) {
                {
                    name = "Windy";
                    description = "The ball trajectory is more unpredictable.";
                };
            };
            // On run event
            case (#rainy) {
                {
                    name = "Rainy";
                    description = "Running injuries are more common.";
                };
            };
            // On catch event
            // On hit event
            case (#foggy) {
                {
                    name = "Foggy";
                    description = "Catching and hitting the ball is harder due to visibility.";
                };
            };
            // On strike event
            case (#extraStrike) {
                {
                    name = "Extra Strike";
                    description = "Players get an extra strike before getting out.";
                };
            };
        };
    };
};


File: src/backend/models/MutableState.mo
import Player "Player";
import Team "Team";
import TrieMap "mo:base/TrieMap";
import Buffer "mo:base/Buffer";
import Iter "mo:base/Iter";
import Nat32 "mo:base/Nat32";
import Debug "mo:base/Debug";
import StadiumTypes "../stadium/Types";
import FieldPosition "FieldPosition";
import Skill "Skill";
import Base "Base";

module {

    public type MutableTeamPositions = {
        var pitcher : Player.PlayerId;
        var firstBase : Player.PlayerId;
        var secondBase : Player.PlayerId;
        var thirdBase : Player.PlayerId;
        var shortStop : Player.PlayerId;
        var leftField : Player.PlayerId;
        var centerField : Player.PlayerId;
        var rightField : Player.PlayerId;
    };

    public type MutableTeamState = {
        id : Nat;
        name : Text;
        logoUrl : Text;
        color : (Nat8, Nat8, Nat8);
        var score : Int;
        positions : MutableTeamPositions;
    };

    public type MutableBaseState = {
        var atBat : Player.PlayerId;
        var firstBase : ?Player.PlayerId;
        var secondBase : ?Player.PlayerId;
        var thirdBase : ?Player.PlayerId;
    };

    public type MutableTurnLog = {
        events : Buffer.Buffer<StadiumTypes.Event>;
    };

    public type MutableRoundLog = {
        turns : Buffer.Buffer<MutableTurnLog>;
    };

    public type MutableMatchLog = {
        rounds : Buffer.Buffer<MutableRoundLog>;
    };

    public class MutableMatchState(immutableState : StadiumTypes.Match) = {

        private func toMutableTeam(team : StadiumTypes.TeamState) : MutableTeamState {
            {
                id = team.id;
                name = team.name;
                logoUrl = team.logoUrl;
                color = team.color;
                var score = team.score;
                positions = toMutableTeamPositions(team.positions);
            };
        };

        private func toMutableTeamPositions(positions : FieldPosition.TeamPositions) : MutableTeamPositions {
            {
                var pitcher = positions.pitcher;
                var firstBase = positions.firstBase;
                var secondBase = positions.secondBase;
                var thirdBase = positions.thirdBase;
                var shortStop = positions.shortStop;
                var leftField = positions.leftField;
                var centerField = positions.centerField;
                var rightField = positions.rightField;
            };
        };

        private func toMutableTurnLog(turn : StadiumTypes.TurnLog) : MutableTurnLog {
            {
                events = turn.events
                |> Iter.fromArray(_)
                |> Buffer.fromIter<StadiumTypes.Event>(_);
            };
        };

        private func toMutableRoundLog(round : StadiumTypes.RoundLog) : MutableRoundLog {
            {
                turns = round.turns
                |> Iter.fromArray(_)
                |> Iter.map(_, toMutableTurnLog)
                |> Buffer.fromIter<MutableTurnLog>(_);
            };
        };

        private func toMutableLog(log : StadiumTypes.MatchLog) : MutableMatchLog {
            {
                rounds = log.rounds
                |> Iter.fromArray(_)
                |> Iter.map(_, toMutableRoundLog)
                |> Buffer.fromIter<MutableRoundLog>(_);
            };
        };

        public var offenseTeamId = immutableState.offenseTeamId;
        public var team1 = toMutableTeam(immutableState.team1);
        public var team2 = toMutableTeam(immutableState.team2);
        public let aura = immutableState.aura;
        public var bases = {
            var atBat = immutableState.bases.atBat;
            var firstBase = immutableState.bases.firstBase;
            var secondBase = immutableState.bases.secondBase;
            var thirdBase = immutableState.bases.thirdBase;
        };
        public var log = toMutableLog(immutableState.log);
        public var outs = immutableState.outs;
        public var strikes = immutableState.strikes;
        public var players = immutableState.players.vals()
        |> Iter.map<StadiumTypes.PlayerStateWithId, (Nat32, MutablePlayerStateWithId)>(
            _,
            func(player : StadiumTypes.PlayerStateWithId) : (Nat32, MutablePlayerStateWithId) {
                let state : MutablePlayerStateWithId = {
                    id = player.id;
                    name = player.name;
                    var teamId = player.teamId;
                    var condition = player.condition;
                    skills = toMutableSkills(player.skills);
                    matchStats = {
                        battingStats = {
                            var atBats = player.matchStats.battingStats.atBats;
                            var hits = player.matchStats.battingStats.hits;
                            var strikeouts = player.matchStats.battingStats.strikeouts;
                            var runs = player.matchStats.battingStats.runs;
                            var homeRuns = player.matchStats.battingStats.homeRuns;
                        };
                        catchingStats = {
                            var successfulCatches = player.matchStats.catchingStats.successfulCatches;
                            var missedCatches = player.matchStats.catchingStats.missedCatches;
                            var throws = player.matchStats.catchingStats.throws;
                            var throwOuts = player.matchStats.catchingStats.throwOuts;
                        };
                        pitchingStats = {
                            var pitches = player.matchStats.pitchingStats.pitches;
                            var strikes = player.matchStats.pitchingStats.strikes;
                            var hits = player.matchStats.pitchingStats.hits;
                            var strikeouts = player.matchStats.pitchingStats.strikeouts;
                            var runs = player.matchStats.pitchingStats.runs;
                            var homeRuns = player.matchStats.pitchingStats.homeRuns;
                        };
                        var injuries = player.matchStats.injuries;
                    };
                };
                (player.id, state);
            },
        )
        |> TrieMap.fromEntries<Nat32, MutablePlayerStateWithId>(_, Nat32.equal, func(h : Nat32) : Nat32 = h);

        public func getTeamPlayers(teamId : Team.TeamId) : Iter.Iter<(Player.PlayerId, MutablePlayerState)> {
            players.entries()
            |> Iter.filter(
                _,
                func((_, player) : (Nat32, MutablePlayerState)) : Bool {
                    player.teamId == teamId;
                },
            );
        };
        public func getPlayerState(playerId : Player.PlayerId) : MutablePlayerStateWithId {
            let ?player = players.get(playerId) else Debug.trap("Player not found for 'getPlayerState': " # Nat32.toText(playerId));
            player;
        };
        public func getDefensePositionOfPlayer(playerId : Player.PlayerId) : ?FieldPosition.FieldPosition {
            let defensiveTeam = getDefenseTeamState();
            if (defensiveTeam.positions.firstBase == playerId) {
                return ? #firstBase;
            };
            if (defensiveTeam.positions.secondBase == playerId) {
                return ? #secondBase;
            };
            if (defensiveTeam.positions.thirdBase == playerId) {
                return ? #thirdBase;
            };
            if (defensiveTeam.positions.shortStop == playerId) {
                return ? #shortStop;
            };
            if (defensiveTeam.positions.pitcher == playerId) {
                return ? #pitcher;
            };
            if (defensiveTeam.positions.leftField == playerId) {
                return ? #leftField;
            };
            if (defensiveTeam.positions.centerField == playerId) {
                return ? #centerField;
            };
            if (defensiveTeam.positions.rightField == playerId) {
                return ? #rightField;
            };
            null;
        };
        public func getOffensivePositionOfPlayer(playerId : Player.PlayerId) : ?Base.Base {
            if (bases.firstBase == ?playerId) {
                return ? #firstBase;
            };
            if (bases.secondBase == ?playerId) {
                return ? #secondBase;
            };
            if (bases.thirdBase == ?playerId) {
                return ? #thirdBase;
            };
            if (bases.atBat == playerId) {
                return ? #homeBase;
            };
            null;
        };

        public func getPlayerAtBase(base : Base.Base) : ?MutablePlayerStateWithId {
            let playerId = switch (base) {
                case (#firstBase) bases.firstBase;
                case (#secondBase) bases.secondBase;
                case (#thirdBase) bases.thirdBase;
                case (#homeBase) ?bases.atBat;
            };
            switch (playerId) {
                case (null) null;
                case (?pId) ?getPlayerState(pId);
            };
        };
        public func getOffenseTeamState() : MutableTeamState {
            switch (offenseTeamId) {
                case (#team1) team1;
                case (#team2) team2;
            };
        };
        public func getDefenseTeamState() : MutableTeamState {
            switch (offenseTeamId) {
                case (#team1) team2;
                case (#team2) team1;
            };
        };
        public func getDefenseTeamId() : Team.TeamId {
            switch (offenseTeamId) {
                case (#team1) #team2;
                case (#team2) #team1;
            };
        };
        public func getTeamState(teamId : Team.TeamId) : MutableTeamState {
            switch (teamId) {
                case (#team1) team1;
                case (#team2) team2;
            };
        };

        public func getPlayerAtDefensivePosition(position : FieldPosition.FieldPosition) : Player.PlayerId {
            let defensiveTeam = getDefenseTeamState();
            switch (position) {
                case (#firstBase) defensiveTeam.positions.firstBase;
                case (#secondBase) defensiveTeam.positions.secondBase;
                case (#thirdBase) defensiveTeam.positions.thirdBase;
                case (#shortStop) defensiveTeam.positions.shortStop;
                case (#pitcher) defensiveTeam.positions.pitcher;
                case (#leftField) defensiveTeam.positions.leftField;
                case (#centerField) defensiveTeam.positions.centerField;
                case (#rightField) defensiveTeam.positions.rightField;
            };
        };

        public func addEvent(event : StadiumTypes.Event) {
            if (log.rounds.size() == 0) {
                addNewRound();
            };
            let currentRound = log.rounds.get(log.rounds.size() - 1);
            if (currentRound.turns.size() == 0) {
                currentRound.turns.add({
                    events = Buffer.Buffer<StadiumTypes.Event>(0);
                });
            };
            let currentTurn = currentRound.turns.get(currentRound.turns.size() - 1);
            currentTurn.events.add(event);
        };

        public func startTurn() {
            if (log.rounds.size() == 0) {
                addNewRound();
            };
            let currentRound = log.rounds.get(log.rounds.size() - 1);
            currentRound.turns.add({
                events = Buffer.Buffer<StadiumTypes.Event>(0);
            });
        };

        public func endRound() {
            addNewRound();
        };

        private func addNewRound() {
            let turns = Buffer.Buffer<MutableTurnLog>(0);
            turns.add({
                events = Buffer.Buffer<StadiumTypes.Event>(0);
            });
            log.rounds.add({
                turns = Buffer.Buffer<MutableTurnLog>(0);
            });
        };
    };

    public type MutablePlayerSkills = {
        var battingPower : Int;
        var battingAccuracy : Int;
        var throwingAccuracy : Int;
        var throwingPower : Int;
        var catching : Int;
        var defense : Int;
        var speed : Int;
    };

    public type MutablePlayerMatchStats = {
        battingStats : {
            var atBats : Nat;
            var hits : Nat;
            var strikeouts : Nat;
            var runs : Nat;
            var homeRuns : Nat;
        };
        catchingStats : {
            var successfulCatches : Nat;
            var missedCatches : Nat;
            var throws : Nat;
            var throwOuts : Nat;
        };
        pitchingStats : {
            var pitches : Nat;
            var strikes : Nat;
            var hits : Nat;
            var strikeouts : Nat;
            var runs : Nat;
            var homeRuns : Nat;
        };
        var injuries : Nat;
    };

    public type MutablePlayerState = {
        name : Text;
        var teamId : Team.TeamId;
        var condition : Player.PlayerCondition;
        skills : MutablePlayerSkills;
        matchStats : MutablePlayerMatchStats;
    };

    public type MutablePlayerStateWithId = MutablePlayerState and {
        id : Player.PlayerId;
    };

    public func toMutableSkills(skills : Player.Skills) : MutablePlayerSkills {
        {
            var battingPower = skills.battingPower;
            var battingAccuracy = skills.battingAccuracy;
            var throwingPower = skills.throwingPower;
            var throwingAccuracy = skills.throwingAccuracy;
            var catching = skills.catching;
            var defense = skills.defense;
            var speed = skills.speed;
        };
    };

    public func getPlayerSkill(skills : MutablePlayerSkills, skill : Skill.Skill) : Int {
        switch (skill) {
            case (#battingPower) skills.battingPower;
            case (#battingAccuracy) skills.battingAccuracy;
            case (#throwingPower) skills.throwingPower;
            case (#throwingAccuracy) skills.throwingAccuracy;
            case (#catching) skills.catching;
            case (#defense) skills.defense;
            case (#speed) skills.speed;
        };
    };

    public func modifyPlayerSkill(skills : MutablePlayerSkills, skill : Skill.Skill, value : Int) {
        switch (skill) {
            case (#battingPower) skills.battingPower += value;
            case (#battingAccuracy) skills.battingAccuracy += value;
            case (#throwingPower) skills.throwingPower += value;
            case (#throwingAccuracy) skills.throwingAccuracy += value;
            case (#catching) skills.catching += value;
            case (#defense) skills.defense += value;
            case (#speed) skills.speed += value;
        };
    };
};


File: src/backend/models/Player.mo
import FieldPosition "FieldPosition";
module {
    public type PlayerId = Nat32;

    public type PlayerFluff = {
        name : Text;
        title : Text;
        description : Text;
        quirks : [Text];
        likes : [Text];
        dislikes : [Text];
    };

    public type Player = PlayerFluff and {
        id : Nat32;
        teamId : Nat;
        skills : Skills;
        position : FieldPosition.FieldPosition;
    };
    public type Skills = {
        battingAccuracy : Int;
        battingPower : Int;
        throwingAccuracy : Int;
        throwingPower : Int;
        catching : Int;
        defense : Int;
        speed : Int;

    };

    public type Injury = {
        #twistedAnkle;
        #brokenLeg;
        #brokenArm;
        #concussion;
    };

    public type PlayerCondition = {
        #ok;
        #injured : Injury;
        #dead;
    };

    public type PlayerMatchStats = {
        battingStats : {
            atBats : Nat;
            hits : Nat;
            strikeouts : Nat;
            runs : Nat;
            homeRuns : Nat;
        };
        catchingStats : {
            successfulCatches : Nat;
            missedCatches : Nat;
            throws : Nat;
            throwOuts : Nat;
        };
        pitchingStats : {
            pitches : Nat;
            strikes : Nat;
            hits : Nat;
            strikeouts : Nat;
            runs : Nat;
            homeRuns : Nat;
        };
        injuries : Nat;
    };

    public type PlayerMatchStatsWithId = PlayerMatchStats and {
        playerId : PlayerId;
    };
};


File: src/backend/models/Scenario.mo
import Skill "Skill";
import Nat "mo:base/Nat";
import Text "mo:base/Text";
import Player "Player";
import FieldPosition "FieldPosition";

module {

    public type TargetTeam = {
        #choosingTeam;
    };

    public type TargetPosition = {
        teamId : TargetTeam;
        position : FieldPosition.FieldPosition;
    };

    public type Target = {
        #league;
        #teams : [TargetTeam];
        #positions : [TargetPosition];
    };

    public type Duration = {
        #indefinite;
        #matches : Nat;
    };

    public type Effect = {
        #skill : {
            target : Target;
            skill : Skill.Skill;
            duration : Duration;
            delta : Int;
        };
        #injury : {
            target : Target;
            injury : Player.Injury;
        };
        #entropy : {
            team : TargetTeam;
            delta : Int;
        };
        #energy : {
            team : TargetTeam;
            value : {
                #flat : Int;
            };
        };
        #oneOf : [(Nat, Effect)]; // Weighted choices
        #allOf : [Effect];
        #noEffect;
    };

    public type PlayerEffectOutcome = {
        #skill : {
            target : TargetInstance;
            skill : Skill.Skill;
            duration : Duration;
            delta : Int;
        };
        #injury : {
            target : TargetInstance;
            injury : Player.Injury;
        };
    };

    public type TeamEffectOutcome = {
        #entropy : {
            teamId : Nat;
            delta : Int;
        };
        #energy : {
            teamId : Nat;
            delta : Int;
        };
    };

    public type EffectOutcome = PlayerEffectOutcome or TeamEffectOutcome;

    public type TargetInstance = {
        #league;
        #teams : [Nat];
        #positions : [TargetPositionInstance];
    };

    public type TargetPositionInstance = {
        teamId : Nat;
        position : FieldPosition.FieldPosition;
    };

    public type ScenarioOption = {
        title : Text;
        description : Text;
    };

    public type ScenarioOptionWithEffect = ScenarioOption and {
        effect : Effect;
    };

    public type Scenario = {
        id : Text;
        title : Text;
        description : Text;
        options : [ScenarioOptionWithEffect];
        metaEffect : MetaEffect;
        state : ScenarioState;
    };

    public type ScenarioState = {
        #notStarted;
        #inProgress;
        #resolved : ScenarioStateResolved;
    };

    public type ScenarioStateResolved = {
        teamChoices : [{
            teamId : Nat;
            option : Nat;
        }];
        effectOutcomes : [EffectOutcome];
    };

    public type MetaEffect = {
        #threshold : {
            threshold : Nat;
            over : Effect;
            under : Effect;
            options : [{
                value : {
                    #fixed : Int;
                    #weightedChance : [(Nat, Int)];
                };
            }];
        };
        #leagueChoice : {
            options : [{
                effect : Effect;
            }];
        };
        #pickASide : {
            options : [{
                sideId : Text;
            }];
        };
        // #winnerTakeAllBid : {
        //     prize : Effect;
        //     options : [{
        //         // TODO
        //     }];
        // };
        #lottery : {
            prize : Effect;
            options : [{
                tickets : Nat;
            }];
        };
        #proportionalBid : {
            prize : {
                #skill : {
                    skill : Skill.Skill;
                    target : {
                        #position : FieldPosition.FieldPosition;
                    };
                    duration : Duration;
                    total : Nat;
                };
            };
            options : [{
                bidValue : Nat;
            }];
        };
        #noEffect;
    };

};


File: src/backend/models/Season.mo
import Time "mo:base/Time";
import Principal "mo:base/Principal";
import MatchAura "MatchAura";
import Team "Team";
import Player "Player";
import FieldPosition "FieldPosition";

module {

    public type SeasonStatus = {
        #notStarted;
        #starting;
        #inProgress : InProgressSeason;
        #completed : CompletedSeason;
    };

    public type InProgressSeason = {
        teams : [TeamInfo];
        players : [Player.Player];
        matchGroups : [InProgressSeasonMatchGroupVariant];
    };

    public type InProgressSeasonMatchGroupVariant = {
        #notScheduled : NotScheduledMatchGroup;
        #scheduled : ScheduledMatchGroup;
        #inProgress : InProgressMatchGroup;
        #completed : CompletedMatchGroup;
    };

    public type TeamInfo = {
        id : Nat;
        name : Text;
        logoUrl : Text;
        positions : FieldPosition.TeamPositions;
        color : (Nat8, Nat8, Nat8);
    };

    public type NotScheduledMatchGroup = {
        time : Time.Time;
        matches : [NotScheduledMatch];
    };

    public type TeamAssignment = {
        #predetermined : Nat;
        #seasonStandingIndex : Nat; // Current standing calculation
        #winnerOfMatch : Nat; // Look at previous match group match id winner
    };

    public type NotScheduledMatch = {
        team1 : TeamAssignment;
        team2 : TeamAssignment;
    };

    public type ScheduledMatchGroup = {
        time : Time.Time;
        timerId : Nat;
        stadiumId : Principal;
        matches : [ScheduledMatch];
    };

    public type ScheduledTeamInfo = { id : Nat };

    public type ScheduledMatch = {
        team1 : ScheduledTeamInfo;
        team2 : ScheduledTeamInfo;
        aura : MatchAura.MatchAuraWithMetaData;
    };

    public type InProgressMatchGroup = {
        time : Time.Time;
        stadiumId : Principal;
        matches : [InProgressMatch];
    };

    public type InProgressTeam = {
        id : Nat;
    };

    public type InProgressMatch = {
        team1 : InProgressTeam;
        team2 : InProgressTeam;
        aura : MatchAura.MatchAura;
    };

    public type CompletedMatchTeam = {
        id : Nat;
        score : Int;
    };

    public type CompletedMatch = {
        team1 : CompletedMatchTeam;
        team2 : CompletedMatchTeam;
        aura : MatchAura.MatchAura;
        winner : Team.TeamIdOrTie;
    };

    public type CompletedMatchGroup = {
        time : Time.Time;
        matches : [CompletedMatch];
    };

    // Completed Season
    public type CompletedSeason = {
        championTeamId : Nat;
        runnerUpTeamId : Nat;
        teams : [CompletedSeasonTeam];
        matchGroups : [CompletedMatchGroup];
    };

    public type CompletedSeasonTeam = TeamInfo and {
        wins : Nat;
        losses : Nat;
        totalScore : Int;
    };
};


File: src/backend/models/Skill.mo
import Player "Player";
import PseudoRandomX "mo:random/PseudoRandomX";

module {

    public type Skill = {
        #battingAccuracy;
        #battingPower;
        #throwingAccuracy;
        #throwingPower;
        #catching;
        #defense;
        #speed;
    };

    public func getRandom(prng : PseudoRandomX.PseudoRandomGenerator) : Skill {
        let allSkills = [
            #battingAccuracy,
            #battingPower,
            #throwingAccuracy,
            #throwingPower,
            #catching,
            #defense,
            #speed,
        ]; // TODO how to get this list from variant
        let skillIndex = prng.nextNat(0, allSkills.size() - 1);
        return allSkills[skillIndex];
    };

    public func get(skills : Player.Skills, skill : Skill) : Int {
        switch (skill) {
            case (#battingAccuracy) skills.battingAccuracy;
            case (#battingPower) skills.battingPower;
            case (#throwingAccuracy) skills.throwingAccuracy;
            case (#throwingPower) skills.throwingPower;
            case (#catching) skills.catching;
            case (#defense) skills.defense;
            case (#speed) skills.speed;
        };
    };

    public func modify(skills : Player.Skills, skill : Skill, delta : Int) : Player.Skills {
        switch (skill) {
            case (#battingAccuracy) {
                return {
                    skills with
                    battingAccuracy = skills.battingAccuracy + delta
                };
            };
            case (#battingPower) {
                return {
                    skills with
                    battingPower = skills.battingPower + delta
                };
            };
            case (#throwingAccuracy) {
                return {
                    skills with
                    throwingAccuracy = skills.throwingAccuracy + delta
                };
            };
            case (#throwingPower) {
                return {
                    skills with
                    throwingPower = skills.throwingPower + delta
                };
            };
            case (#catching) {
                return {
                    skills with
                    catching = skills.catching + delta
                };
            };
            case (#defense) {
                return {
                    skills with
                    defense = skills.defense + delta
                };
            };
            case (#speed) {
                return {
                    skills with
                    speed = skills.speed + delta
                };
            };
        };
    };
};


File: src/backend/models/Team.mo
module {

    public type TeamId = {
        #team1;
        #team2;
    };

    public type TeamIdOrBoth = TeamId or { #bothTeams };

    public type TeamIdOrTie = TeamId or { #tie };

    public type Team = {
        name : Text;
        logoUrl : Text;
        motto : Text;
        description : Text;
        color : (Nat8, Nat8, Nat8);
        entropy : Nat;
        energy : Int;
    };

    public type TeamWithId = Team and {
        id : Nat;
    };
};


File: src/backend/models/Trait.mo
import Text "mo:base/Text";
import Skill "Skill";
module {
    public type Effect = {
        #skill : {
            skill : ?Skill.Skill;
            delta : Int;
        };
    };

    public type Trait = {
        // TODO Look into hashing the values or something
        // for the ID and maybe some versioning, so that the
        // data is immutable. Can retire bad ones and add new ones
        // BUT will that be an issue for updating the game or can versions
        // make that ok?
        id : Text;
        name : Text;
        description : Text;
        effects : [Effect];
    };

    public func hash(trait : Trait) : Nat32 = Text.hash(trait.id);

    public func equal(a : Trait, b : Trait) : Bool = a.id == b.id;
};


File: src/backend/nftLedger/NftLedger.mo
import Array "mo:base/Array";
import Vec "mo:vector";
import Principal "mo:base/Principal";
import Time "mo:base/Time";
import Nat "mo:base/Nat";
import D "mo:base/Debug";
import CertifiedData "mo:base/CertifiedData";
import CertTree "mo:cert/CertTree";
import ICRC7 "mo:icrc7-mo";
import ICRC30 "mo:icrc30-mo";
import ICRC3 "mo:icrc3-mo";

module NftLedger {

    type Account = ICRC7.Account;
    type Environment = ICRC7.Environment;
    type Value = ICRC7.Value;
    type NFT = ICRC7.NFT;
    type NFTShared = ICRC7.NFTShared;
    type NFTMap = ICRC7.NFTMap;
    type OwnerOfResponse = ICRC7.OwnerOfResponse;
    type OwnerOfResponses = ICRC7.OwnerOfResponses;
    type TransferArgs = ICRC7.TransferArgs;
    type TransferResponse = ICRC7.TransferResponse;
    type TransferError = ICRC7.TransferArgs;
    type TokenApproval = ICRC30.TokenApproval;
    type CollectionApproval = ICRC30.CollectionApproval;
    type ApprovalInfo = ICRC30.ApprovalInfo;
    type ApprovalResponse = ICRC30.ApprovalResponse;
    type ApprovalResult = ICRC30.ApprovalResult;
    type ApprovalCollectionResponse = ICRC30.ApprovalCollectionResponse;
    type RevokeTokensArgs = ICRC30.RevokeTokensArgs;
    type RevokeTokensResponseItem = ICRC30.RevokeTokensResponseItem;
    type RevokeCollectionArgs = ICRC30.RevokeCollectionArgs;
    type RevokeCollectionResponseItem = ICRC30.RevokeCollectionResponseItem;
    type TransferFromArgs = ICRC30.TransferFromArgs;
    type TransferFromResponse = ICRC30.TransferFromResponse;
    type RevokeTokensResponse = ICRC30.RevokeTokensResponse;
    type RevokeCollectionResponse = ICRC30.RevokeCollectionResponse;

    public type InitArgs = {
        icrc7_args : ICRC7.InitArgs;
        icrc30_args : ICRC30.InitArgs;
        icrc3_args : ICRC3.InitArgs;
    };

    public type InitMsg = {
        caller : Principal;
    };

    public class NftLedger(_init_msg : InitMsg, _args : InitArgs) {
        var init_msg = _init_msg; // TODO stable

        stable var icrc7_migration_state = ICRC7.init(
            ICRC7.initialState(),
            #v0_1_0(#id),
            _args.icrc7_args,
            init_msg.caller,
        );

        let #v0_1_0(#data(icrc7_state_current)) = icrc7_migration_state;

        var icrc30_migration_state = ICRC30.init(
            ICRC30.initialState(),
            #v0_1_0(#id),
            _args.icrc30_args,
            init_msg.caller,
        ); // TODO stable

        let #v0_1_0(#data(icrc30_state_current)) = icrc30_migration_state;

        private var _icrc7 : ?ICRC7.ICRC7 = null;
        private var _icrc30 : ?ICRC30.ICRC30 = null;

        private func get_icrc7_state() : ICRC7.CurrentState {
            return icrc7_state_current;
        };

        private func get_icrc30_state() : ICRC30.CurrentState {
            return icrc30_state_current;
        };

        stable var icrc3_migration_state = ICRC3.init(
            ICRC3.initialState(),
            #v0_1_0(#id),
            _args.icrc3_args,
            init_msg.caller,
        );

        let #v0_1_0(#data(icrc3_state_current)) = icrc3_migration_state;

        private var _icrc3 : ?ICRC3.ICRC3 = null;

        private func get_icrc3_state() : ICRC3.CurrentState {
            return icrc3_state_current;
        };

        stable let cert_store : CertTree.Store = CertTree.newStore();
        let ct = CertTree.Ops(cert_store);

        private func get_certificate_store() : CertTree.Store {
            D.print("returning cert store " # debug_show (cert_store));
            return cert_store;
        };

        private func updated_certification(cert : Blob, lastIndex : Nat) : Bool {

            D.print("updating the certification " # debug_show (CertifiedData.getCertificate(), ct.treeHash()));
            ct.setCertifiedData();
            D.print("did the certification " # debug_show (CertifiedData.getCertificate()));
            return true;
        };

        private func get_icrc3_environment() : ICRC3.Environment {
            ?{
                updated_certification = ?updated_certification;
                get_certificate_store = ?get_certificate_store;
            };
        };

        func icrc3() : ICRC3.ICRC3 {
            switch (_icrc3) {
                case (null) {
                    let initclass : ICRC3.ICRC3 = ICRC3.ICRC3(?icrc3_migration_state, Principal.fromActor(this), get_icrc3_environment());
                    _icrc3 := ?initclass;
                    initclass;
                };
                case (?val) val;
            };
        };

        private func get_icrc7_environment() : ICRC7.Environment {
            {
                canister = get_canister;
                get_time = get_time;
                refresh_state = get_icrc7_state;
                add_ledger_transaction = ?icrc3().add_record;
                can_mint = null;
                can_burn = null;
                can_transfer = null;
            };
        };

        private func get_icrc30_environment() : ICRC30.Environment {
            {
                canister = get_canister;
                get_time = get_time;
                refresh_state = get_icrc30_state;
                icrc7 = icrc7();
                can_transfer_from = null;
                can_approve_token = null;
                can_approve_collection = null;
                can_revoke_token_approval = null;
                can_revoke_collection_approval = null;
            };
        };

        func icrc7() : ICRC7.ICRC7 {
            switch (_icrc7) {
                case (null) {
                    let initclass : ICRC7.ICRC7 = ICRC7.ICRC7(?icrc7_migration_state, Principal.fromActor(this), get_icrc7_environment());
                    _icrc7 := ?initclass;
                    initclass;
                };
                case (?val) val;
            };
        };

        func icrc30() : ICRC30.ICRC30 {
            switch (_icrc30) {
                case (null) {
                    let initclass : ICRC30.ICRC30 = ICRC30.ICRC30(?icrc30_migration_state, Principal.fromActor(this), get_icrc30_environment());
                    _icrc30 := ?initclass;
                    initclass;
                };
                case (?val) val;
            };
        };

        //we will use a stable log for this example, but encourage the use of ICRC3 in a full implementation.  see https://github.com/panindustrial/FullNFT.mo

        stable var trx_log = Vec.new<ICRC7.Value>();

        func add_trx(entry : Value, entrytop : ?Value) : Nat {
            let trx = Vec.new<(Text, Value)>();

            Vec.add(trx, ("tx", entry));

            switch (entrytop) {
                case (?top_level) {
                    switch (top_level) {
                        case (#Map(items)) {
                            for (thisItem in items.vals()) {
                                Vec.add(trx, (thisItem.0, thisItem.1));
                            };
                        };
                        case (_) {};
                    };
                };
                case (null) {};
            };

            let thisTrx = #Map(Vec.toArray(trx));
            Vec.add(trx_log, thisTrx);
            return (Vec.size(trx_log) - 1);
        };

        private var canister_principal : ?Principal = null;

        private func get_canister() : Principal {
            switch (canister_principal) {
                case (null) {
                    canister_principal := ?Principal.fromActor(this);
                    Principal.fromActor(this);
                };
                case (?val) {
                    val;
                };
            };
        };

        private func get_time() : Int {
            //note: you may want to implement a testing framework where you can set this time manually
            /* switch(state_current.testing.time_mode){
          case(#test){
              state_current.testing.test_time;
          };
          case(#standard){
               Time.now();
          };
      }; */
            Time.now();
        };
    };
};


File: src/backend/nftLedger/NftLedgerActor.mo
import Array "mo:base/Array";
import Vec "mo:vector";
import Principal "mo:base/Principal";
import Time "mo:base/Time";
import Nat "mo:base/Nat";
import D "mo:base/Debug";
import CertifiedData "mo:base/CertifiedData";
import CertTree "mo:cert/CertTree";
import ICRC7 "mo:icrc7-mo";
import ICRC30 "mo:icrc30-mo";
import ICRC3 "mo:icrc3-mo";
import Types "Types";
import NftLedger "NftLedger";

shared (_init_msg) actor class NftLedgerActor(_args : NftLedger.InitArgs) : Types.NftLedgerActor = this {

    private let ledger : NftLedger.NftLedger = NftLedger.NftLedger(_args, init_msg);

    public query func icrc7_symbol() : async Text {

        return switch (icrc7().get_ledger_info().symbol) {
            case (?val) val;
            case (null) "";
        };
    };

    public query func icrc7_name() : async Text {
        return switch (icrc7().get_ledger_info().name) {
            case (?val) val;
            case (null) "";
        };
    };

    public query func icrc7_description() : async ?Text {
        return icrc7().get_ledger_info().description;
    };

    public query func icrc7_logo() : async ?Text {
        return icrc7().get_ledger_info().logo;
    };

    public query func icrc7_max_memo_size() : async ?Nat {
        return ?icrc7().get_ledger_info().max_memo_size;
    };

    public query func icrc7_total_supply() : async Nat {
        return icrc7().get_stats().nft_count;
    };

    public query func icrc7_supply_cap() : async ?Nat {
        return icrc7().get_ledger_info().supply_cap;
    };

    public query func icrc30_max_approvals_per_token_or_collection() : async ?Nat {
        return ?icrc30().get_ledger_info().max_approvals_per_token_or_collection;
    };

    public query func icrc7_max_query_batch_size() : async ?Nat {
        return ?icrc7().get_ledger_info().max_query_batch_size;
    };

    public query func icrc7_max_update_batch_size() : async ?Nat {
        return ?icrc7().get_ledger_info().max_update_batch_size;
    };

    public query func icrc7_default_take_value() : async ?Nat {
        return ?icrc7().get_ledger_info().default_take_value;
    };

    public query func icrc7_max_take_value() : async ?Nat {
        return ?icrc7().get_ledger_info().max_take_value;
    };

    public query func icrc30_max_revoke_approvals() : async ?Nat {
        return ?icrc30().get_ledger_info().max_revoke_approvals;
    };

    public query func icrc7_collection_metadata() : async {
        metadata : [(Text, Value)];
    } {

        let ledger_info = icrc7().get_ledger_info();
        let ledger_info30 = icrc30().get_ledger_info();
        let results = Vec.new<(Text, Value)>();

        switch (ledger_info.symbol) {
            case (?val) Vec.add(results, ("icrc7:symbol", #Text(val)));
            case (null) {};
        };

        switch (ledger_info.name) {
            case (?val) Vec.add(results, ("icrc7:name", #Text(val)));
            case (null) {};
        };

        switch (ledger_info.description) {
            case (?val) Vec.add(results, ("icrc7:description", #Text(val)));
            case (null) {};
        };

        switch (ledger_info.logo) {
            case (?val) Vec.add(results, ("icrc7:logo", #Text(val)));
            case (null) {};
        };

        Vec.add(results, ("icrc7:total_supply", #Nat(icrc7().get_stats().nft_count)));

        switch (ledger_info.supply_cap) {
            case (?val) Vec.add(results, ("icrc7:supply_cap", #Nat(val)));
            case (null) {};
        };

        Vec.add(results, ("icrc30:max_approvals_per_token_or_collection", #Nat(ledger_info30.max_approvals_per_token_or_collection)));
        Vec.add(results, ("icrc7:max_query_batch_size", #Nat(ledger_info.max_query_batch_size)));
        Vec.add(results, ("icrc7:max_update_batch_size", #Nat(ledger_info.max_update_batch_size)));
        Vec.add(results, ("icrc7:default_take_value", #Nat(ledger_info.default_take_value)));
        Vec.add(results, ("icrc7:max_take_value", #Nat(ledger_info.max_take_value)));
        Vec.add(results, ("icrc30:max_revoke_approvals", #Nat(ledger_info30.max_revoke_approvals)));

        return {
            metadata = Vec.toArray(results);
        };
    };

    public query func icrc30_metadata() : async { metadata : [(Text, Value)] } {

        let ledger_info30 = icrc30().get_ledger_info();
        let results = Vec.new<(Text, Value)>();

        Vec.add(results, ("max_approvals_per_token_or_collection", #Nat(ledger_info30.max_approvals_per_token_or_collection)));

        Vec.add(results, ("icrc7:name", #Nat(ledger_info30.max_revoke_approvals)));

        return {
            metadata = Vec.toArray(results);
        };
    };

    public query func icrc7_token_metadata(token_ids : [Nat]) : async [{
        token_id : Nat;
        metadata : [(Text, Value)];
    }] {
        return icrc7().token_metadata(token_ids);
    };

    public query func icrc7_owner_of(token_ids : [Nat]) : async OwnerOfResponses {

        switch (icrc7().get_token_owners(token_ids)) {
            case (#ok(val)) val;
            case (#err(err)) D.trap(err);
        };
    };

    public query func icrc7_balance_of(account : Account) : async Nat {
        return icrc7().get_token_owners_tokens_count(account);
    };

    public query func icrc7_tokens(prev : ?Nat, take : ?Nat) : async [Nat] {
        return icrc7().get_tokens_paginated(prev, take);
    };

    public query func icrc7_tokens_of(account : Account, prev : ?Nat, take : ?Nat) : async [Nat] {
        return icrc7().get_tokens_of_paginated(account, prev, take);
    };

    public query func icrc30_is_approved(spender : Account, from_subaccount : ?Blob, token_id : Nat) : async Bool {
        return icrc30().is_approved(spender, from_subaccount, token_id);
    };

    public query func icrc30_get_approvals(token_ids : [Nat], prev : ?TokenApproval, take : ?Nat) : async [TokenApproval] {

        return icrc30().get_token_approvals(token_ids, prev, take);
    };

    public query func icrc30_get_collection_approvals(owner : Account, prev : ?CollectionApproval, take : ?Nat) : async [CollectionApproval] {

        return icrc30().get_collection_approvals(owner, prev, take);
    };

    public query func icrc7_supported_standards() : async ICRC7.SupportedStandards {
        //todo: figure this out
        return [
            {
                name = "ICRC-7";
                url = "https://github.com/dfinity/ICRC/ICRCs/ICRC-7";
            },
            {
                name = "ICRC-30";
                url = "https://github.com/dfinity/ICRC/ICRCs/ICRC-30";
            },
        ];
    };

    //Update calls

    public shared (msg) func icrc30_approve(token_ids : [Nat], approval : ApprovalInfo) : async ApprovalResponse {

        switch (icrc30().approve_transfers(msg.caller, token_ids, approval)) {
            case (#ok(val)) val;
            case (#err(err)) D.trap(err);
        };
    };

    public shared (msg) func icrc30_approve_collection(approval : ApprovalInfo) : async ApprovalCollectionResponse {
        icrc30().approve_collection(msg.caller, approval);
    };

    public shared (msg) func icrc7_transfer(args : TransferArgs) : async TransferResponse {
        icrc7().transfer(msg.caller, args);
    };

    public shared (msg) func icrc30_transfer_from(args : TransferFromArgs) : async TransferFromResponse {
        icrc30().transfer_from(msg.caller, args);
    };

    public shared (msg) func icrc30_revoke_token_approvals(args : RevokeTokensArgs) : async RevokeTokensResponse {
        icrc30().revoke_token_approvals(msg.caller, args);
    };

    public shared (msg) func icrc30_revoke_collection_approvals(args : RevokeCollectionArgs) : async RevokeCollectionResponse {
        icrc30().revoke_collection_approvals(msg.caller, args);
    };

    /////////
    // ICRC3 endpoints
    /////////

    public query func icrc3_get_blocks(args : [ICRC3.TransactionRange]) : async ICRC3.GetTransactionsResult {
        return icrc3().get_blocks(args);
    };

    public query func icrc3_get_archives(args : ICRC3.GetArchivesArgs) : async ICRC3.GetArchivesResult {
        return icrc3().get_archives(args);
    };

    public query func icrc3_get_tip_certificate() : async ?ICRC3.DataCertificate {
        return icrc3().get_tip_certificate();
    };

    public query func get_tip() : async ICRC3.Tip {
        return icrc3().get_tip();
    };

};


File: src/backend/nftLedger/Types.mo
import ICRC7 "mo:icrc7-mo";
import ICRC30 "mo:icrc30-mo";
import ICRC3 "mo:icrc3-mo";

module {
    public type NftLedgerActor = ICRC3.Service and ICRC7.Service and ICRC30.Service and actor {

    };

    public type NftLedgerActorInfo = {

    };

    public type NftLedgerActorInfoWithId = NftLedgerActorInfo and {
        id : Text;
    };
};


File: src/backend/players/PlayerHandler.mo
import Player "../models/Player";
import Types "./Types";
import Buffer "mo:base/Buffer";
import HashMap "mo:base/HashMap";
import Nat "mo:base/Nat";
import Iter "mo:base/Iter";
import Nat32 "mo:base/Nat32";
import Debug "mo:base/Debug";
import Array "mo:base/Array";
import TextX "mo:xtended-text/TextX";
import Scenario "../models/Scenario";
import FieldPosition "../models/FieldPosition";
import IterTools "mo:itertools/Iter";
import Skill "../models/Skill";

module {

    type PlayerInfo = Player.PlayerFluff and {
        id : Nat32;
        teamId : Nat;
        position : FieldPosition.FieldPosition;
        skills : Player.Skills;
        condition : Player.PlayerCondition;
    };

    type RetiredPlayer = Player.PlayerFluff and {
        id : Nat32;
        name : Text;
        teamId : Nat;
        position : FieldPosition.FieldPosition;
        skills : Player.Skills;
    };

    public type StableData = {
        players : [PlayerInfo];
        retiredPlayers : [RetiredPlayer];
        unusedFluff : [Player.PlayerFluff];
    };

    public class PlayerHandler(stableData : StableData) {
        let players : HashMap.HashMap<Nat32, PlayerInfo> = buildPlayerMap(stableData.players);
        let retiredPlayers : HashMap.HashMap<Nat32, RetiredPlayer> = buildRetiredPlayerMap(stableData.retiredPlayers);
        let unusedFluff : Buffer.Buffer<Player.PlayerFluff> = Buffer.fromArray(stableData.unusedFluff);

        public func toStableData() : StableData {
            {
                players = Iter.toArray(players.vals());
                retiredPlayers = Iter.toArray(retiredPlayers.vals());
                unusedFluff = Buffer.toArray(unusedFluff);
            };
        };

        public func get(id : Nat32) : ?PlayerInfo {
            players.get(id);
        };

        public func getAll(teamId : ?Nat) : [PlayerInfo] {
            switch (teamId) {
                case (null) Iter.toArray(players.vals());
                case (?teamId) {
                    players.vals()
                    |> Iter.filter(
                        _,
                        func(player : PlayerInfo) : Bool = player.teamId == teamId,
                    )
                    |> Iter.toArray(_);
                };
            };
        };

        public func addFluff(fluff : Player.PlayerFluff) : {
            #ok;
            #invalid : [Types.InvalidError];
        } {

            let errors = Buffer.Buffer<Types.InvalidError>(0);
            if (TextX.isEmptyOrWhitespace(fluff.name)) {
                errors.add(#nameNotSpecified);
            };
            if (isNameTaken(fluff.name)) {
                errors.add(#nameTaken);
            };
            if (errors.size() > 0) {
                return #invalid(Buffer.toArray(errors));
            };

            unusedFluff.add(fluff);
            #ok;
        };

        public func applyEffects(effects : [Scenario.PlayerEffectOutcome]) : {
            #ok;
        } {

            for (effect in effects.vals()) {
                switch (effect) {
                    case (#skill(skillEffect)) {
                        let targetPlayerIds = getTargetPlayerIds(skillEffect.target);
                        for (playerId in Iter.fromArray(targetPlayerIds)) {
                            updatePlayer(
                                playerId,
                                func(player) {
                                    let newSkills = Skill.modify(player.skills, skillEffect.skill, skillEffect.delta);

                                    {
                                        player with
                                        skills = newSkills
                                    };
                                },
                            );
                        };
                    };
                    case (#injury(injuryEffect)) {
                        let targetPlayerIds = getTargetPlayerIds(injuryEffect.target);
                        for (playerId in Iter.fromArray(targetPlayerIds)) {
                            updatePlayer(
                                playerId,
                                func(player) {
                                    // TODO how to remove effect?
                                    {
                                        player with
                                        injury = injuryEffect.injury;
                                    };
                                },
                            );
                        };
                    };
                };
            };
            #ok;
        };

        public func swapTeamPositions(
            teamId : Nat,
            position1 : FieldPosition.FieldPosition,
            position2 : FieldPosition.FieldPosition,
        ) : {
            #ok;
        } {
            let getPlayerFromPosition = func(position : FieldPosition.FieldPosition) : PlayerInfo {
                let iter = Iter.filter(
                    players.vals(),
                    func(player : PlayerInfo) : Bool = player.teamId == teamId and player.position == position,
                );
                let ?player = iter.next() else Debug.trap("Player not found for team " # Nat.toText(teamId) # " and position " # debug_show (position1));
                return player;
            };

            let player1 = getPlayerFromPosition(position1);
            let player2 = getPlayerFromPosition(position2);

            players.put(player1.id, { player1 with position = position2 });
            players.put(player2.id, { player2 with position = position1 });

            #ok;
        };

        public func populateTeamRoster(teamId : Nat) : {
            #ok : [PlayerInfo];
            #missingFluff;
        } {

            // TODO validate that the teamid is valid?
            let teamPlayers = getAll(?teamId);
            let allPositions : [FieldPosition.FieldPosition] = [
                #pitcher,
                #firstBase,
                #secondBase,
                #thirdBase,
                #shortStop,
                #leftField,
                #centerField,
                #rightField,
            ];
            var nextPlayerId = getNextPlayerId();
            let newPlayersBuffer = Buffer.Buffer<PlayerInfo>(1);
            label l for (position in Iter.fromArray(allPositions)) {
                let positionIsFilled = teamPlayers
                |> Iter.fromArray(_)
                |> IterTools.any(
                    _,
                    func(p : PlayerInfo) : Bool {
                        p.position == position;
                    },
                );
                if (positionIsFilled) {
                    continue l;
                };
                let ?playerFluff = unusedFluff.getOpt(0) else return #missingFluff; // TODO random or next?

                // TODO randomize skills
                let skills : Player.Skills = switch (position) {
                    case (#pitcher) {
                        {
                            battingAccuracy = 0;
                            battingPower = 0;
                            throwingAccuracy = 1;
                            throwingPower = 1;
                            catching = 0;
                            defense = 0;
                            speed = 0;
                        };
                    };
                    case (#firstBase or #secondBase or #thirdBase or #shortStop) {
                        {
                            battingAccuracy = 1;
                            battingPower = 1;
                            throwingAccuracy = 0;
                            throwingPower = 0;
                            catching = 0;
                            defense = 0;
                            speed = 0;
                        };
                    };
                    case (#leftField or #centerField or #rightField) {
                        {
                            battingAccuracy = 0;
                            battingPower = 0;
                            throwingAccuracy = 0;
                            throwingPower = 0;
                            catching = 1;
                            defense = 0;
                            speed = 1;
                        };
                    };
                };
                let newPlayer : PlayerInfo = {
                    playerFluff with
                    id = nextPlayerId;
                    skills = skills;
                    position = position;
                    teamId = teamId;
                    condition = #ok;
                };
                newPlayersBuffer.add({
                    newPlayer with
                    teamId = teamId;
                    id = nextPlayerId;
                });
                players.put(newPlayer.id, newPlayer);
                nextPlayerId += 1;
                ignore unusedFluff.remove(0);
            };
            #ok(Buffer.toArray(newPlayersBuffer));
        };

        private func getNextPlayerId() : Nat32 {
            var nextId : Nat32 = 0;
            for (player in players.vals()) {
                if (player.id >= nextId) {
                    nextId := player.id + 1;
                };
            };
            for (player in retiredPlayers.vals()) {
                if (player.id >= nextId) {
                    nextId := player.id + 1;
                };
            };
            nextId;
        };

        private func updatePlayer(playerId : Nat32, updateFunc : (player : PlayerInfo) -> PlayerInfo) {
            let ?player = players.get(playerId) else Debug.trap("Player not found: " # Nat32.toText(playerId)); // TODO trap?

            let newPlayer = updateFunc(player);

            players.put(playerId, newPlayer);
        };

        private func getTargetPlayerIds(target : Scenario.TargetInstance) : [Nat32] {
            let filterFunc : PlayerInfo -> Bool = switch (target) {
                case (#league) func(player : PlayerInfo) : Bool = true;
                case (#teams(teamIds)) func(player : PlayerInfo) : Bool {
                    Array.indexOf(player.teamId, teamIds, Nat.equal) != null;
                };
                case (#positions(positions)) func(player : PlayerInfo) : Bool {
                    IterTools.any(positions.vals(), func(p : Scenario.TargetPositionInstance) : Bool = p.position == player.position and p.teamId == player.teamId);
                };
            };
            players.vals()
            |> Iter.filter<PlayerInfo>(
                _,
                filterFunc,
            )
            |> Iter.map(
                _,
                func(player : PlayerInfo) : Nat32 = player.id,
            )
            |> Iter.toArray(_);
        };

        private func isNameTaken(name : Text) : Bool {
            for (player in getAll(null).vals()) {
                if (player.name == name) {
                    return true;
                };
            };
            for (player in unusedFluff.vals()) {
                if (player.name == name) {
                    return true;
                };
            };
            for (player in retiredPlayers.vals()) {
                if (player.name == name) {
                    return true;
                };
            };
            false;
        };
    };

    private func buildPlayerMap(players : [PlayerInfo]) : HashMap.HashMap<Nat32, PlayerInfo> {
        players.vals()
        |> Iter.map<PlayerInfo, (Nat32, PlayerInfo)>(
            _,
            func(p : PlayerInfo) : (Nat32, PlayerInfo) { (p.id, p) },
        )
        |> HashMap.fromIter<Nat32, PlayerInfo>(_, players.size(), Nat32.equal, func(x : Nat32) : Nat32 = x);
    };

    private func buildRetiredPlayerMap(retiredPlayers : [RetiredPlayer]) : HashMap.HashMap<Nat32, RetiredPlayer> {
        retiredPlayers.vals()
        |> Iter.map<RetiredPlayer, (Nat32, RetiredPlayer)>(
            _,
            func(player : RetiredPlayer) : (Nat32, RetiredPlayer) {
                (player.id, player);
            },
        )
        |> HashMap.fromIter<Nat32, RetiredPlayer>(_, retiredPlayers.size(), Nat32.equal, func(x : Nat32) : Nat32 = x);
    };
};


File: src/backend/players/PlayersActor.mo
import Trie "mo:base/Trie";
import Player "../models/Player";
import Nat32 "mo:base/Nat32";
import Debug "mo:base/Debug";
import PseudoRandomX "mo:random/PseudoRandomX";
import Principal "mo:base/Principal";
import Iter "mo:base/Iter";
import Nat "mo:base/Nat";
import Bool "mo:base/Bool";
import Types "Types";
import FieldPosition "../models/FieldPosition";
import PlayerHandler "PlayerHandler";
// import LeagueActor "canister:league"; TODO

actor : Types.PlayerActor {
    type Prng = PseudoRandomX.PseudoRandomGenerator;

    stable var stableData = {
        players : PlayerHandler.StableData = {
            players = [];
            retiredPlayers = [];
            unusedFluff = [];
        };
        teamsCanisterId : ?Principal = null;
    };

    var teamsCanisterId = stableData.teamsCanisterId;
    var playerHandler = PlayerHandler.PlayerHandler(stableData.players);
    stable var stats = Trie.empty<Nat32, Trie.Trie<Nat, Player.PlayerMatchStats>>();

    system func preupgrade() {
        stableData := {
            players = playerHandler.toStableData();
            teamsCanisterId = teamsCanisterId;
        };
    };

    system func postupgrade() {
        teamsCanisterId := stableData.teamsCanisterId;
        playerHandler := PlayerHandler.PlayerHandler(stableData.players);
    };

    public shared ({ caller }) func setTeamsCanisterId(canisterId : Principal) : async Types.SetTeamsCanisterIdResult {
        if (not isLeague(caller)) {
            return #notAuthorized;
        };
        teamsCanisterId := ?canisterId;
        #ok;
    };

    public shared ({ caller }) func addFluff(request : Types.CreatePlayerFluffRequest) : async Types.CreatePlayerFluffResult {
        if (not isLeague(caller)) {
            return #notAuthorized;
        };
        playerHandler.addFluff(request);
    };

    public query func getPlayer(id : Nat32) : async Types.GetPlayerResult {
        switch (playerHandler.get(id)) {
            case (?player) {
                #ok(player);
            };
            case (null) {
                #notFound;
            };
        };
    };

    public query func getTeamPlayers(teamId : Nat) : async [Player.Player] {
        playerHandler.getAll(?teamId);
    };

    public query func getAllPlayers() : async [Player.Player] {
        playerHandler.getAll(null);
    };

    public shared ({ caller }) func populateTeamRoster(teamId : Nat) : async Types.PopulateTeamRosterResult {
        if (not isLeague(caller)) {
            return #notAuthorized;
        };
        playerHandler.populateTeamRoster(teamId);
    };

    public shared ({ caller }) func applyEffects(request : Types.ApplyEffectsRequest) : async Types.ApplyEffectsResult {
        if (not isLeague(caller)) {
            return #notAuthorized;
        };
        playerHandler.applyEffects(request);
    };

    public shared ({ caller }) func swapTeamPositions(
        teamId : Nat,
        position1 : FieldPosition.FieldPosition,
        position2 : FieldPosition.FieldPosition,
    ) : async Types.SwapPlayerPositionsResult {
        if (teamsCanisterId == null) {
            Debug.trap("Teams canister ID is not set");
        };
        if (?caller != teamsCanisterId and not isLeague(caller)) {
            return #notAuthorized;
        };
        playerHandler.swapTeamPositions(teamId, position1, position2);
    };

    public shared ({ caller }) func addMatchStats(matchGroupId : Nat, playerStats : [Player.PlayerMatchStatsWithId]) : async Types.AddMatchStatsResult {
        if (not isLeague(caller)) {
            return #notAuthorized;
        };

        let matchGroupKey = {
            key = matchGroupId;
            hash = Nat32.fromNat(matchGroupId); // TODO
        };
        for (playerStat in Iter.fromArray(playerStats)) {
            let playerKey = {
                key = playerStat.playerId;
                hash = playerStat.playerId;
            };
            let playerMatchGroupStats = switch (Trie.get(stats, playerKey, Nat32.equal)) {
                case (null) Trie.empty<Nat, Player.PlayerMatchStats>();
                case (?p) p;
            };

            let (newPlayerMatchGroupStats, oldPlayerStat) = Trie.put(playerMatchGroupStats, matchGroupKey, Nat.equal, playerStat);
            if (oldPlayerStat != null) {
                Debug.trap("Player match stats already exist for match group: " # Nat.toText(matchGroupId) # " and player: " # Nat32.toText(playerStat.playerId));
            };
            let (newStats, _) = Trie.put(stats, playerKey, Nat32.equal, newPlayerMatchGroupStats);
            stats := newStats;
        };
        #ok;
    };

    public shared ({ caller }) func onSeasonEnd() : async Types.OnSeasonEndResult {
        if (not isLeague(caller)) {
            return #notAuthorized;
        };
        // TODO
        stats := Trie.empty<Nat32, Trie.Trie<Nat, Player.PlayerMatchStats>>();
        #ok;
    };

    private func isLeague(_ : Principal) : Bool {
        // TODO
        // caller == Principal.fromActor(LeagueActor);
        true;
    };
};


File: src/backend/players/Types.mo
import Player "../models/Player";
import Scenario "../models/Scenario";
import FieldPosition "../models/FieldPosition";
module {

    public type PlayerActor = actor {
        addFluff : (request : CreatePlayerFluffRequest) -> async CreatePlayerFluffResult;
        getPlayer : query (id : Nat32) -> async GetPlayerResult;
        getTeamPlayers : query (teamId : Nat) -> async [Player.Player];
        getAllPlayers : query () -> async [Player.Player];
        populateTeamRoster : (teamId : Nat) -> async PopulateTeamRosterResult;
        applyEffects : (request : ApplyEffectsRequest) -> async ApplyEffectsResult;
        onSeasonEnd : () -> async OnSeasonEndResult;
        swapTeamPositions : (
            teamId : Nat,
            position1 : FieldPosition.FieldPosition,
            position2 : FieldPosition.FieldPosition,
        ) -> async SwapPlayerPositionsResult;
        addMatchStats : (matchGroupId : Nat, playerStats : [Player.PlayerMatchStatsWithId]) -> async AddMatchStatsResult;
        setTeamsCanisterId : (canisterId : Principal) -> async SetTeamsCanisterIdResult;
    };

    public type SetTeamsCanisterIdResult = {
        #ok;
        #notAuthorized;
    };

    public type AddMatchStatsResult = {
        #ok;
        #notAuthorized;
    };

    public type SwapPlayerPositionsResult = {
        #ok;
        #notAuthorized;
    };

    public type OnSeasonEndResult = {
        #ok;
        #notAuthorized;
    };

    public type ApplyEffectsRequest = [Scenario.PlayerEffectOutcome];

    public type ApplyEffectsResult = {
        #ok;
        #notAuthorized;
    };

    public type PopulateTeamRosterResult = {
        #ok : [Player.Player];
        #missingFluff;
        #notAuthorized;
        // #teamNotFound; // TODO?
    };

    public type CreatePlayerFluffRequest = {
        name : Text;
        title : Text;
        description : Text;
        quirks : [Text];
        likes : [Text];
        dislikes : [Text];
    };

    public type InvalidError = {
        #nameTaken;
        #nameNotSpecified;
    };

    public type CreatePlayerFluffResult = {
        #ok;
        #notAuthorized;
        #invalid : [InvalidError];
    };

    public type GetPlayerResult = {
        #ok : Player.Player;
        #notFound;
    };

    public type SetPlayerTeamResult = {
        #ok;
        #playerNotFound;
    };

};


File: src/backend/stadium/HookCompiler.mo
import StadiumTypes "Types";
import Hook "../models/Hook";
import PseudoRandomX "mo:random/PseudoRandomX";
import Iter "mo:base/Iter";

module {
    type Prng = PseudoRandomX.PseudoRandomGenerator;

    public type PreCompiledHooks = {
        matchStart : ?Hook.Hook<()>;
        matchEnd : ?Hook.Hook<()>;
        roundStart : ?Hook.Hook<()>;
        roundEnd : ?Hook.Hook<()>;
        onDodge : ?Hook.Hook<Hook.SkillTestContext>;
        onPitch : ?Hook.Hook<Hook.SkillTestContext>;
        onSwing : ?Hook.Hook<Hook.SkillTestContext>;
        onHit : ?Hook.Hook<Hook.SkillTestContext>;
        onCatch : ?Hook.Hook<Hook.SkillTestContext>;
    };

    public func compile(_ : StadiumTypes.Match) : Hook.CompiledHooks {
        let allHooks = [
            // fromAura(state.aura)
        ];

        var matchStart : ?Hook.Hook<()> = null;
        var matchEnd : ?Hook.Hook<()> = null;
        var roundStart : ?Hook.Hook<()> = null;
        var roundEnd : ?Hook.Hook<()> = null;
        var onDodge : ?Hook.Hook<Hook.SkillTestContext> = null;
        var onPitch : ?Hook.Hook<Hook.SkillTestContext> = null;
        var onSwing : ?Hook.Hook<Hook.SkillTestContext> = null;
        var onHit : ?Hook.Hook<Hook.SkillTestContext> = null;
        var onCatch : ?Hook.Hook<Hook.SkillTestContext> = null;
        for (hook in Iter.fromArray(allHooks)) {
            matchStart := mergeHook(matchStart, hook.matchStart);
            matchEnd := mergeHook(matchEnd, hook.matchEnd);
            roundStart := mergeHook(roundStart, hook.roundStart);
            roundEnd := mergeHook(roundEnd, hook.roundEnd);
            onDodge := mergeHook(onDodge, hook.onDodge);
            onPitch := mergeHook(onPitch, hook.onPitch);
            onSwing := mergeHook(onSwing, hook.onSwing);
            onHit := mergeHook(onHit, hook.onHit);
            onCatch := mergeHook(onCatch, hook.onCatch);
        };
        // If there's no hook, then just return an empty hook
        let hookOrEmpty = func<T>(hook : ?Hook.Hook<T>) : Hook.Hook<T> {
            switch (hook) {
                case (null) func(request : Hook.HookRequest<T>) : Hook.HookResult<T> {
                    {
                        updatedContext = request.context;
                    };
                };
                case (?h) h;
            };
        };
        {
            matchStart = hookOrEmpty(matchStart);
            matchEnd = hookOrEmpty(matchEnd);
            roundStart = hookOrEmpty(roundStart);
            roundEnd = hookOrEmpty(roundEnd);
            onDodge = hookOrEmpty(onDodge);
            onPitch = hookOrEmpty(onPitch);
            onSwing = hookOrEmpty(onSwing);
            onHit = hookOrEmpty(onHit);
            onCatch = hookOrEmpty(onCatch);
        };
    };

    private func mergeHook<T>(hook1 : ?Hook.Hook<T>, hook2 : ?Hook.Hook<T>) : ?Hook.Hook<T> {
        switch (hook1, hook2) {
            case (null, null) return null;
            case (null, ?h2) return ?h2; // If no previous hook, then make only hook
            case (?h1, null) return ?h1; // If no new hook, then keep old hook
            case (?h1, ?h2) {
                // call h1, then h2
                return ?(
                    func(request : Hook.HookRequest<T>) : Hook.HookResult<T> {
                        // TODO callback
                        let result1 = h1(request);
                        let request2 = {
                            request with
                            context = result1.updatedContext;
                        };
                        let result2 = h2(request2);
                        {
                            updatedContext = result2.updatedContext;
                        };
                    }
                );
            };
        };
    };

    // private func shuffleAndBoostHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     let matchStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         // Shuffle all the players' positions but boost their stats

    //         let team = switch (teamId) {
    //             case (#team1) request.state.team1;
    //             case (#team2) request.state.team2;
    //         };

    //         // Shuffle positions
    //         let newPositions = Buffer.fromArray<Player.PlayerId>([
    //             team.positions.pitcher,
    //             team.positions.firstBase,
    //             team.positions.secondBase,
    //             team.positions.thirdBase,
    //             team.positions.shortStop,
    //             team.positions.leftField,
    //             team.positions.centerField,
    //             team.positions.rightField,
    //         ]);
    //         request.prng.shuffleBuffer(newPositions);

    //         team.positions.pitcher := newPositions.get(0);
    //         team.positions.firstBase := newPositions.get(1);
    //         team.positions.secondBase := newPositions.get(2);
    //         team.positions.thirdBase := newPositions.get(3);
    //         team.positions.shortStop := newPositions.get(4);
    //         team.positions.leftField := newPositions.get(5);
    //         team.positions.centerField := newPositions.get(6);
    //         team.positions.rightField := newPositions.get(7);

    //         // Boost skills
    //         let randomSkill = Skill.getRandom(request.prng);
    //         for ((playerId, playerState) in request.state.getTeamPlayers(teamId)) {
    //             MutableState.modifyPlayerSkill(playerState.skills, randomSkill, 1);
    //         };
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = ?matchStartHook;
    //         matchEnd = null;
    //         roundStart = null;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func offensiveHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     let matchStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         // Increase batting power and lower catching
    //         for ((playerId, playerState) in request.state.getTeamPlayers(teamId)) {
    //             MutableState.modifyPlayerSkill(playerState.skills, #battingPower, 1);
    //             MutableState.modifyPlayerSkill(playerState.skills, #catching, -1);
    //         };
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = ?matchStartHook;
    //         matchEnd = null;
    //         roundStart = null;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func defensiveHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     let matchStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         // Increase catching and lower batting power
    //         for ((playerId, playerState) in request.state.getTeamPlayers(teamId)) {
    //             MutableState.modifyPlayerSkill(playerState.skills, #catching, 1);
    //             MutableState.modifyPlayerSkill(playerState.skills, #battingPower, -1);
    //         };
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = ?matchStartHook;
    //         matchEnd = null;
    //         roundStart = null;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func hittersDebtHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     let matchStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         switch (teamId) {
    //             case (#team1) {
    //                 request.state.team1.score -= 1;
    //             };
    //             case (#team2) {
    //                 request.state.team2.score -= 1;
    //             };
    //         };
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = ?matchStartHook;
    //         matchEnd = null;
    //         roundStart = null;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func ragePitchHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     let matchStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         // Increase throwing power and lower throwing accuracy for pitchers
    //         let teamState = request.state.getTeamState(teamId);
    //         let playerState = request.state.getPlayerState(teamState.positions.pitcher);
    //         MutableState.modifyPlayerSkill(playerState.skills, #throwingPower, 1);
    //         MutableState.modifyPlayerSkill(playerState.skills, #throwingAccuracy, -1);
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = ?matchStartHook;
    //         matchEnd = null;
    //         roundStart = null;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func bubbleHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     var usedOnPlayers : TrieSet.Set<Player.PlayerId> = TrieSet.empty();
    //     let onDodge = func(request : Hook.HookRequest<Hook.SkillTestContext>) : Hook.HookResult<Hook.SkillTestContext> {
    //         let alreadyUsed = TrieSet.mem(usedOnPlayers, request.context.playerId, request.context.playerId, Nat32.equal);
    //         let updatedContext = if (not alreadyUsed) {
    //             usedOnPlayers := TrieSet.put(usedOnPlayers, request.context.playerId, request.context.playerId, Nat32.equal);

    //             {
    //                 request.context with
    //                 result = {
    //                     request.context.result with
    //                     crit = true; // TODO what if already crit?
    //                 };
    //             };
    //         } else {
    //             request.context; //Skip
    //         };
    //         {
    //             updatedContext = updatedContext;
    //         };
    //     };
    //     {
    //         matchStart = null;
    //         matchEnd = null;
    //         roundStart = null;
    //         roundEnd = null;
    //         onDodge = ?onDodge;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func underdogHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     // Better stats when team is behind, worse when ahead
    //     let roundStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         // TODO
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = null;
    //         matchEnd = null;
    //         roundStart = ?roundStartHook;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func piousHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     let roundStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         // TODO
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = null;
    //         matchEnd = null;
    //         roundStart = ?roundStartHook;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func confidentHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     let roundStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         // TODO
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = null;
    //         matchEnd = null;
    //         roundStart = ?roundStartHook;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func moraleFlywheelHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     let roundStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         // TODO
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = null;
    //         matchEnd = null;
    //         roundStart = ?roundStartHook;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };

    // private func badManagementHook(teamId : Team.TeamId) : PreCompiledHooks {
    //     let matchStartHook = func(request : Hook.HookRequest<()>) : Hook.HookResult<()> {
    //         // TODO
    //         {
    //             updatedContext = ();
    //         };
    //     };
    //     {
    //         matchStart = ?matchStartHook;
    //         matchEnd = null;
    //         roundStart = null;
    //         roundEnd = null;
    //         onDodge = null;
    //         onPitch = null;
    //         onSwing = null;
    //         onHit = null;
    //         onCatch = null;
    //     };
    // };
};


File: src/backend/stadium/MatchSimulator.mo
import Principal "mo:base/Principal";
import Buffer "mo:base/Buffer";
import Nat32 "mo:base/Nat32";
import StadiumTypes "../stadium/Types";
import Player "../models/Player";
import Debug "mo:base/Debug";
import Int "mo:base/Int";
import Prelude "mo:base/Prelude";
import Iter "mo:base/Iter";
import Text "mo:base/Text";
import Order "mo:base/Order";
import PseudoRandomX "mo:random/PseudoRandomX";
import MatchAura "../models/MatchAura";
import Base "../models/Base";
import Team "../models/Team";
import FieldPosition "../models/FieldPosition";
import Skill "../models/Skill";
import Hook "../models/Hook";
import MutableState "../models/MutableState";
import HookCompiler "HookCompiler";

module {

    type PlayerId = Player.PlayerId;
    type MatchAura = MatchAura.MatchAura;
    type Prng = PseudoRandomX.PseudoRandomGenerator;

    type SimulationResult = {
        #endMatch : MatchEndReason;
        #inProgress;
    };

    type MatchEndReason = {
        #noMoreRounds;
        #stateBroken : StadiumTypes.BrokenStateError;
    };

    public type TeamInitData = {
        id : Nat;
        name : Text;
        logoUrl : Text;
        color : (Nat8, Nat8, Nat8);
        positions : {
            firstBase : Player.Player;
            secondBase : Player.Player;
            thirdBase : Player.Player;
            shortStop : Player.Player;
            pitcher : Player.Player;
            leftField : Player.Player;
            centerField : Player.Player;
            rightField : Player.Player;
        };
    };

    public func initState(
        aura : MatchAura.MatchAura,
        team1 : TeamInitData,
        team2 : TeamInitData,
        team1StartOffense : Bool,
        prng : Prng,
    ) : StadiumTypes.Match {
        let (team1State, team1Players) = buildTeamState(team1, #team1);
        let (team2State, team2Players) = buildTeamState(team2, #team2);
        let offensePlayers = if (team1StartOffense) {
            team1Players;
        } else {
            team2Players;
        };
        let randomIndex = prng.nextNat(0, offensePlayers.size() - 1);
        let atBatPlayer = offensePlayers.get(randomIndex);

        let players = Buffer.merge(
            team1Players,
            team2Players,
            func(
                p1 : StadiumTypes.PlayerStateWithId,
                p2 : StadiumTypes.PlayerStateWithId,
            ) : Order.Order = Nat32.compare(p1.id, p2.id),
        );
        {
            offenseTeamId = if (team1StartOffense) #team1 else #team2;
            team1 = team1State;
            team2 = team2State;
            aura = aura;
            log = {
                rounds = [];
            };
            players = Buffer.toArray(players);
            bases = {
                atBat = atBatPlayer.id;
                firstBase = null;
                secondBase = null;
                thirdBase = null;
            };
            round = 0;
            outs = 0;
            strikes = 0;
        };
    };

    private func buildTeamState(
        team : TeamInitData,
        teamId : Team.TeamId,
    ) : (StadiumTypes.TeamState, Buffer.Buffer<StadiumTypes.PlayerStateWithId>) {

        let mapPlayer = func(player : Player.Player) : StadiumTypes.PlayerStateWithId = {
            id = player.id;
            name = player.name;
            teamId = teamId;
            condition = #ok;
            skills = player.skills;
            position = player.position;
            matchStats = {
                battingStats = {
                    atBats = 0;
                    hits = 0;
                    runs = 0;
                    strikeouts = 0;
                    homeRuns = 0;
                };
                catchingStats = {
                    successfulCatches = 0;
                    missedCatches = 0;
                    throws = 0;
                    throwOuts = 0;
                };
                pitchingStats = {
                    pitches = 0;
                    strikes = 0;
                    hits = 0;
                    runs = 0;
                    strikeouts = 0;
                    homeRuns = 0;
                };
                injuries = 0;
            };
        };
        let playerStates = Buffer.Buffer<StadiumTypes.PlayerStateWithId>(8);
        playerStates.add(mapPlayer(team.positions.pitcher));
        playerStates.add(mapPlayer(team.positions.firstBase));
        playerStates.add(mapPlayer(team.positions.secondBase));
        playerStates.add(mapPlayer(team.positions.thirdBase));
        playerStates.add(mapPlayer(team.positions.shortStop));
        playerStates.add(mapPlayer(team.positions.leftField));
        playerStates.add(mapPlayer(team.positions.centerField));
        playerStates.add(mapPlayer(team.positions.rightField));

        let teamState : StadiumTypes.TeamState = {
            id = team.id;
            name = team.name;
            logoUrl = team.logoUrl;
            color = team.color;
            score = 0;
            positions = {
                pitcher = team.positions.pitcher.id;
                firstBase = team.positions.firstBase.id;
                secondBase = team.positions.secondBase.id;
                thirdBase = team.positions.thirdBase.id;
                shortStop = team.positions.shortStop.id;
                leftField = team.positions.leftField.id;
                centerField = team.positions.centerField.id;
                rightField = team.positions.rightField.id;
            };
        };
        (teamState, playerStates);
    };

    public func tick(match : StadiumTypes.Match, random : Prng) : StadiumTypes.TickResult {
        let compiledHooks = HookCompiler.compile(match);
        let simulation = MatchSimulation(match, random, compiledHooks);
        simulation.tick();
    };

    class MatchSimulation(
        initialState : StadiumTypes.Match,
        prng : Prng,
        compiledHooks : Hook.CompiledHooks,
    ) {

        let state : MutableState.MutableMatchState = MutableState.MutableMatchState(initialState);

        public func tick() : StadiumTypes.TickResult {
            state.startTurn();
            if (state.log.rounds.size() < 1) {
                // Need to log first batter, others handled when batter switches
                updateStats(
                    state.bases.atBat,
                    func(stats : MutableState.MutablePlayerMatchStats) {
                        stats.battingStats.atBats += 1;
                    },
                );
                ignore compiledHooks.matchStart({
                    prng = prng;
                    state = state;
                    context = ();
                });
            };

            // TODO divine intervention
            // let roll = Hook.trigger(state, #divineInterventionRoll);
            // let divineInterventionRoll = prng.nextNat(0, 999);
            // let result = if (divineInterventionRoll <= 9) {
            //     state.log.add({
            //         message = "Divine intervention!";
            //         isImportant = true;
            //     });
            //     let ?randomPlayerId = getRandomAvailablePlayer(null, null, false) else Prelude.unreachable();
            //     blessOrCursePlayer(randomPlayerId);
            // } else {
            let result = pitch();
            // };

            buildTickResult(result);
        };

        private func buildTickResult(result : SimulationResult) : StadiumTypes.TickResult {
            let status : StadiumTypes.MatchStatus = switch (result) {
                case (#endMatch(reason)) {
                    let mappedReason = switch (reason) {
                        case (#noMoreRounds) #noMoreRounds;
                        case (#stateBroken(e)) #error(debug_show (e)); // TODO error format
                    };
                    state.addEvent(#matchEnd({ reason = mappedReason }));
                    #completed({ reason = mappedReason });
                };
                case (#inProgress) #inProgress;
            };
            let match = buildLiveMatch();
            {
                match = match;
                status = status;
            };

        };

        private func mapMutableTeam(team : MutableState.MutableTeamState) : StadiumTypes.TeamState {
            {
                id = team.id;
                name = team.name;
                logoUrl = team.logoUrl;
                score = team.score;
                color = team.color;
                positions = {
                    pitcher = team.positions.pitcher;
                    firstBase = team.positions.firstBase;
                    secondBase = team.positions.secondBase;
                    thirdBase = team.positions.thirdBase;
                    shortStop = team.positions.shortStop;
                    leftField = team.positions.leftField;
                    centerField = team.positions.centerField;
                    rightField = team.positions.rightField;
                };
            };
        };

        private func buildLiveMatch() : StadiumTypes.Match {

            let players = Iter.toArray(
                Iter.map(
                    state.players.entries(),
                    func(player : (Nat32, MutableState.MutablePlayerState)) : StadiumTypes.PlayerStateWithId {
                        {
                            id = player.0;
                            name = player.1.name;
                            teamId = player.1.teamId;
                            condition = player.1.condition;
                            skills = {
                                battingPower = player.1.skills.battingPower;
                                battingAccuracy = player.1.skills.battingAccuracy;
                                throwingPower = player.1.skills.throwingPower;
                                throwingAccuracy = player.1.skills.throwingAccuracy;
                                catching = player.1.skills.catching;
                                defense = player.1.skills.defense;
                                speed = player.1.skills.speed;
                            };
                            matchStats = {
                                battingStats = {
                                    atBats = player.1.matchStats.battingStats.atBats;
                                    hits = player.1.matchStats.battingStats.hits;
                                    runs = player.1.matchStats.battingStats.runs;
                                    strikeouts = player.1.matchStats.battingStats.strikeouts;
                                    homeRuns = player.1.matchStats.battingStats.homeRuns;
                                };
                                catchingStats = {
                                    successfulCatches = player.1.matchStats.catchingStats.successfulCatches;
                                    missedCatches = player.1.matchStats.catchingStats.missedCatches;
                                    throws = player.1.matchStats.catchingStats.throws;
                                    throwOuts = player.1.matchStats.catchingStats.throwOuts;

                                };
                                pitchingStats = {
                                    pitches = player.1.matchStats.pitchingStats.pitches;
                                    strikes = player.1.matchStats.pitchingStats.strikes;
                                    hits = player.1.matchStats.pitchingStats.hits;
                                    runs = player.1.matchStats.pitchingStats.runs;
                                    strikeouts = player.1.matchStats.pitchingStats.strikeouts;
                                    homeRuns = player.1.matchStats.pitchingStats.homeRuns;
                                };
                                injuries = player.1.matchStats.injuries;
                            };
                        };
                    },
                )
            );

            let bases = {
                atBat = state.bases.atBat;
                firstBase = state.bases.firstBase;
                secondBase = state.bases.secondBase;
                thirdBase = state.bases.thirdBase;
            };
            let log : StadiumTypes.MatchLog = fromMutableLog(state.log);
            {
                team1 = mapMutableTeam(state.team1);
                team2 = mapMutableTeam(state.team2);
                log = log;
                currentSeed = prng.getCurrentSeed();
                offenseTeamId = state.offenseTeamId;
                aura = state.aura;
                players = players;
                bases = bases;
                outs = state.outs;
                strikes = state.strikes;
            };
        };

        private func fromMutableLog(log : MutableState.MutableMatchLog) : StadiumTypes.MatchLog {
            {
                rounds = log.rounds.vals()
                |> Iter.map(_, fromMutableRoundLog)
                |> Iter.toArray(_);
            };
        };

        private func fromMutableRoundLog(log : MutableState.MutableRoundLog) : StadiumTypes.RoundLog {
            {
                turns = log.turns.vals()
                |> Iter.map(_, fromMutableTurns)
                |> Iter.toArray(_);
            };
        };

        private func fromMutableTurns(log : MutableState.MutableTurnLog) : StadiumTypes.TurnLog {
            {
                events = Buffer.toArray(log.events);
            };
        };

        private func getNextBatter() : PlayerId {

            let playerBuffer = state.players.entries()
            // Only players on offense and not on base
            |> Iter.filter(
                _,
                func(p : (PlayerId, MutableState.MutablePlayerState)) : Bool {
                    p.1.teamId == state.offenseTeamId and state.getOffensivePositionOfPlayer(p.0) == null;
                },
            )
            |> Iter.map(_, func(p : (PlayerId, MutableState.MutablePlayerState)) : PlayerId = p.0)
            |> Buffer.fromIter<PlayerId>(_);

            if (playerBuffer.size() <= 0) {
                Debug.trap("No players available to bat for team: " # debug_show (state.offenseTeamId));
            };

            prng.nextBufferElement(playerBuffer);
        };

        private func roll(
            type_ : { #d10 },
            playerId : Player.PlayerId,
            skill : Skill.Skill,
            hook : ?Hook.Hook<Hook.SkillTestContext>,
        ) : Hook.SkillTestResult {
            let (min, max) = switch (type_) {
                case (#d10) (0, 10);
            };
            var roll = prng.nextNat(min, max);
            let crit = roll == max;
            if (crit) {
                // Reroll for crit value, no double crit
                roll := prng.nextNat(min, max);
            };
            let defensiveTeam = state.getDefenseTeamState();
            let playerState = state.getPlayerState(defensiveTeam.positions.pitcher);
            let playerSkills : MutableState.MutablePlayerSkills = switch (playerState.condition) {
                case (#ok) playerState.skills;
                case (#injured(_)) {
                    // TODO different values for different injuries
                    {
                        var battingPower = playerState.skills.battingPower - 1;
                        var battingAccuracy = playerState.skills.battingAccuracy - 1;
                        var throwingPower = playerState.skills.throwingPower - 1;
                        var throwingAccuracy = playerState.skills.throwingAccuracy - 1;
                        var catching = playerState.skills.catching - 1;
                        var defense = playerState.skills.defense - 1;
                        var speed = playerState.skills.speed - 1;
                    };
                };
                case (#dead) {
                    // TODO 'placeholder construct' skills
                    {
                        var battingPower = 0;
                        var battingAccuracy = 0;
                        var throwingPower = 0;
                        var throwingAccuracy = 0;
                        var catching = 0;
                        var defense = 0;
                        var speed = 0;
                    };
                };
            };
            let modifier = MutableState.getPlayerSkill(playerSkills, skill);
            let modifiedRoll = roll + modifier;
            let postHookValue = switch (hook) {
                case (null) { { value = modifiedRoll; crit = crit } };
                case (?h) {
                    let result = h({
                        prng = prng;
                        state = state;
                        context = {
                            result = { value = modifiedRoll; crit = crit };
                            playerId = playerId;
                            skill = skill;
                        };
                    });
                    result.updatedContext.result;
                };
            };
            postHookValue;
        };

        private func getNetRoll(leftRoll : Hook.SkillTestResult, rightRoll : Hook.SkillTestResult) : Int {
            switch ((leftRoll.crit, rightRoll.crit)) {
                case ((false, false) or (true, true)) {
                    // If both crit or normal, find the delta
                    leftRoll.value - rightRoll.value;
                };
                case ((true, false)) {
                    // Left crit trumps right value
                    leftRoll.value;
                };
                case ((false, true)) {
                    // Right crit trumps left value
                    rightRoll.value;
                };
            };
        };

        private func updateStats(playerId : PlayerId, update : (MutableState.MutablePlayerMatchStats) -> ()) {
            let playerState = state.getPlayerState(playerId);
            update(playerState.matchStats);
        };

        private func pitch() : SimulationResult {
            let defensiveTeam = state.getDefenseTeamState();
            let pitchRoll = roll(
                #d10,
                defensiveTeam.positions.pitcher,
                // TODO what about throwing power?
                #throwingAccuracy,
                ?compiledHooks.onPitch,
            );
            updateStats(
                defensiveTeam.positions.pitcher,
                func(stats : MutableState.MutablePlayerMatchStats) {
                    stats.pitchingStats.pitches += 1;
                },
            );
            state.addEvent(#pitch({ pitcherId = defensiveTeam.positions.pitcher; roll = pitchRoll }));
            swing(pitchRoll);
        };

        private func swing(pitchRoll : Hook.SkillTestResult) : SimulationResult {
            let swingRoll = roll(
                #d10,
                state.bases.atBat,
                #battingAccuracy,
                ?compiledHooks.onSwing,
            );
            let netRoll = getNetRoll(pitchRoll, swingRoll);
            let swingOutcome = if (netRoll == 0) {
                #foul;
            } else if (netRoll > 0) {
                let hitLocation = getHitLocation();
                #hit(hitLocation);
            } else {
                #strike;
            };
            state.addEvent(
                #swing({
                    playerId = state.bases.atBat;
                    roll = swingRoll;
                    pitchRoll = pitchRoll;
                    outcome = swingOutcome;
                })
            );
            switch (swingOutcome) {
                case (#foul) {
                    #inProgress; // TODO?
                };
                case (#hit(location)) {
                    let position = switch (location) {
                        case (#stands) return homeRun();
                        case (#firstBase) #firstBase;
                        case (#secondBase) #secondBase;
                        case (#thirdBase) #thirdBase;
                        case (#shortStop) #shortStop;
                        case (#pitcher) #pitcher;
                        case (#leftField) #leftField;
                        case (#centerField) #centerField;
                        case (#rightField) #rightField;
                    };
                    catchBall(position);
                };
                case (#strike) {
                    strike();
                };
            };
        };

        private func getHitLocation() : StadiumTypes.HitLocation {
            let hitPowerRoll = roll(
                #d10,
                state.bases.atBat,
                #battingPower,
                ?compiledHooks.onHit,
            );
            let defensiveTeam = state.getDefenseTeamState();
            let pitchPowerRoll = roll(
                #d10,
                defensiveTeam.positions.pitcher,
                #throwingPower,
                null,
            );
            let netRoll = getNetRoll(pitchPowerRoll, hitPowerRoll);
            let hitLocation = if (netRoll < 0) {
                // bases
                switch (prng.nextInt(0, 4)) {
                    case (0) #firstBase;
                    case (1) #secondBase;
                    case (2) #thirdBase;
                    case (3) #shortStop;
                    case (4) #pitcher;
                    case (_) Prelude.unreachable();
                };
            } else if (netRoll < 8) {
                // outfield
                switch (prng.nextInt(0, 2)) {
                    case (0) #leftField;
                    case (1) #centerField;
                    case (2) #rightField;
                    case (_) Prelude.unreachable();
                };
            } else {
                // homerun
                #stands;
            };
        };

        private func catchBall(position : FieldPosition.FieldPosition) : SimulationResult {
            let catchingPlayerId = state.getPlayerAtDefensivePosition(position);
            let catchRoll = roll(
                #d10,
                catchingPlayerId,
                #catching,
                ?compiledHooks.onCatch,
            );
            let ballRoll = { crit = false; value = 7 }; // TODO how to handle difficulty?
            let netCatchRoll = getNetRoll(catchRoll, ballRoll);
            if (netCatchRoll <= 0) {

                updateStats(
                    catchingPlayerId,
                    func(stats : MutableState.MutablePlayerMatchStats) {
                        stats.catchingStats.missedCatches += 1;
                    },
                );
                run(position);
            } else {

                updateStats(
                    catchingPlayerId,
                    func(stats : MutableState.MutablePlayerMatchStats) {
                        stats.catchingStats.successfulCatches += 1;
                    },
                );
                state.addEvent(
                    #catch_({
                        playerId = catchingPlayerId;
                        roll = catchRoll;
                        difficulty = ballRoll;
                    })
                );
                // Ball caught, batter is out
                out(state.bases.atBat, #ballCaught);
            };
        };

        private func run(positionWithBall : FieldPosition.FieldPosition) : SimulationResult {
            // Pick a runner on base to try to hit out
            let targetToHit = switch (state.bases.thirdBase) {
                case (null) {
                    // If no one is on third base, pick from 2nd, 1st, or batter
                    let targets = Buffer.Buffer<Player.PlayerId>(3);
                    targets.add(state.bases.atBat);
                    switch (state.bases.firstBase) {
                        case (null) ();
                        case (?firstBaseRunner) targets.add(firstBaseRunner);
                    };
                    switch (state.bases.secondBase) {
                        case (null) ();
                        case (?secondBaseRunner) targets.add(secondBaseRunner);
                    };
                    if (targets.size() <= 1) {
                        // Only one option, no need to roll
                        targets.get(0);
                    } else {
                        // Roll to pick a target
                        let chanceRoll = prng.nextNat(0, targets.size() - 1);
                        targets.get(chanceRoll);
                    };
                };
                case (?thirdBaseRunner) {
                    // If someone is on third base, running home, try to get them out
                    thirdBaseRunner;
                };
            };
            let runRoll = roll(
                #d10,
                targetToHit,
                #speed,
                null, // TODO Hook here
            );
            hitTargetWithBall(targetToHit, runRoll, positionWithBall);
        };

        private func hitTargetWithBall(
            target : Player.PlayerId,
            targetRunRoll : Hook.SkillTestResult,
            positionWithBall : FieldPosition.FieldPosition,
        ) : SimulationResult {
            let playerIdWithBall = state.getPlayerAtDefensivePosition(positionWithBall);
            let pickUpRoll = roll(
                #d10,
                playerIdWithBall,
                #speed,
                null, // TODO Hook here
            );
            let canPickUpInTime = getNetRoll(pickUpRoll, targetRunRoll) >= 0;

            if (canPickUpInTime) {
                let throwRoll = roll(
                    #d10,
                    playerIdWithBall,
                    #throwingAccuracy,
                    null, // TODO Hook here
                );

                updateStats(
                    playerIdWithBall,
                    func(stats : MutableState.MutablePlayerMatchStats) {
                        stats.catchingStats.throws += 1;
                    },
                );
                let netThrowRoll = getNetRoll(throwRoll, targetRunRoll);
                if (netThrowRoll >= 0) {
                    // Runner is hit by the ball
                    updateStats(
                        playerIdWithBall,
                        func(stats : MutableState.MutablePlayerMatchStats) {
                            stats.catchingStats.throwOuts += 1;
                        },
                    );
                    state.addEvent(
                        #throw_({
                            to = target;
                            from = playerIdWithBall;
                        })
                    );

                    let defenseRoll = roll(
                        #d10,
                        target,
                        #defense,
                        null, // TODO Hook here
                    );
                    let damageRoll = getNetRoll({ crit = false; value = netThrowRoll }, defenseRoll);
                    if (damageRoll > 10) {
                        let newInjury = switch (damageRoll) {
                            case (6) #twistedAnkle;
                            case (7) #brokenLeg;
                            case (8) #brokenArm;
                            case (_) #concussion;
                        };
                        injurePlayer({
                            playerId = target;
                            injury = newInjury;
                        });
                        updateStats(
                            target,
                            func(stats : MutableState.MutablePlayerMatchStats) {
                                stats.injuries += 1;
                            },
                        );
                    };
                    // out will handle removing the player from base
                    switch (out(target, #hitByBall)) {
                        case (#endMatch(m)) return #endMatch(m);
                        case (#inProgress) ();
                    };
                };
            } else {
                updateStats(
                    state.bases.atBat,
                    func(stats : MutableState.MutablePlayerMatchStats) {
                        stats.battingStats.hits += 1;
                    },
                );
                let defenseTeam = state.getDefenseTeamState();
                updateStats(
                    defenseTeam.positions.pitcher,
                    func(stats : MutableState.MutablePlayerMatchStats) {
                        stats.pitchingStats.hits += 1;
                    },
                );
            };

            // Shift the rest of the runners by one base
            single();
        };

        private func single() : SimulationResult {
            // Shift everyone by one base
            // 3rd -> home
            let thirdBaseRun = moveBaseToBase({
                from = #thirdBase;
                to = #homeBase;
            });
            let #inProgress = thirdBaseRun else return thirdBaseRun; // Short circuit if end match

            // 2nd -> 3rd
            let secondBaseRun = moveBaseToBase({
                from = #secondBase;
                to = #thirdBase;
            });
            let #inProgress = secondBaseRun else return secondBaseRun; // Short circuit if end match

            // 1st -> 2nd
            let firstBaseRun = moveBaseToBase({
                from = #firstBase;
                to = #secondBase;
            });
            let #inProgress = firstBaseRun else return firstBaseRun; // Short circuit if end match

            // batter -> 1st
            moveBaseToBase({
                from = #homeBase;
                to = #firstBase;
            });
        };

        private func homeRun() : SimulationResult {
            updateStats(
                state.bases.atBat,
                func(stats : MutableState.MutablePlayerMatchStats) {
                    stats.battingStats.homeRuns += 1;
                },
            );

            let defenseTeam = state.getDefenseTeamState();
            updateStats(
                defenseTeam.positions.pitcher,
                func(stats : MutableState.MutablePlayerMatchStats) {
                    stats.pitchingStats.homeRuns += 1;
                },
            );
            // Home run
            // 3rd -> home
            let thirdBaseRun = moveBaseToBase({
                from = #thirdBase;
                to = #homeBase;
            });
            let #inProgress = thirdBaseRun else return thirdBaseRun;

            // 2nd -> Home
            let secondBaseRun = moveBaseToBase({
                from = #secondBase;
                to = #homeBase;
            });
            let #inProgress = secondBaseRun else return secondBaseRun;

            // 1st -> Home
            let firstBaseRun = moveBaseToBase({
                from = #firstBase;
                to = #homeBase;
            });
            let #inProgress = firstBaseRun else return firstBaseRun;

            // Batter -> Home
            moveBaseToBase({
                from = #homeBase;
                to = #firstBase;
            });
        };

        private func strike() : SimulationResult {
            let defenseTeam = state.getDefenseTeamState();
            updateStats(
                defenseTeam.positions.pitcher,
                func(stats : MutableState.MutablePlayerMatchStats) {
                    stats.pitchingStats.strikes += 1;
                },
            );
            state.strikes += 1;
            if (state.strikes >= 3) {
                out(state.bases.atBat, #strikeout);
            } else {
                #inProgress;
            };
        };

        private func out(playerId : Nat32, reason : StadiumTypes.OutReason) : SimulationResult {
            state.strikes := 0;
            state.outs += 1;
            state.addEvent(
                #out({
                    playerId = playerId;
                    reason = reason;
                })
            );
            switch (reason) {
                case (#hitByBall) {};
                case (#ballCaught) {};
                case (#strikeout) {
                    updateStats(
                        playerId,
                        func(stats : MutableState.MutablePlayerMatchStats) {
                            stats.battingStats.strikeouts += 1;
                        },
                    );
                    let defenseTeam = state.getDefenseTeamState();
                    updateStats(
                        defenseTeam.positions.pitcher,
                        func(stats : MutableState.MutablePlayerMatchStats) {
                            stats.pitchingStats.strikeouts += 1;
                        },
                    );
                };
            };
            if (state.outs >= 3) {
                return endRound();
            };
            removePlayerFromBase(playerId);
        };

        private func moveBaseToBase({
            from : Base.Base;
            to : Base.Base;
        }) : SimulationResult {
            let ?player = state.getPlayerAtBase(from) else return #inProgress; // no player to move, skip

            state.addEvent(
                #safeAtBase({
                    playerId = player.id;
                    base = #firstBase;
                })
            );
            switch (to) {
                case (#firstBase) state.bases.firstBase := ?player.id;
                case (#secondBase) state.bases.secondBase := ?player.id;
                case (#thirdBase) state.bases.thirdBase := ?player.id;
                case (#homeBase) {
                    score({ teamId = state.offenseTeamId; amount = 1 });
                    let ?scoringPlayer = state.getPlayerAtBase(from) else Debug.trap("Expected player at base: " # debug_show (from));
                    updateStats(
                        scoringPlayer.id,
                        func(stats : MutableState.MutablePlayerMatchStats) {
                            stats.battingStats.runs += 1;
                        },
                    );

                    let defenseTeam = state.getDefenseTeamState();
                    updateStats(
                        defenseTeam.positions.pitcher,
                        func(stats : MutableState.MutablePlayerMatchStats) {
                            stats.pitchingStats.runs += 1;
                        },
                    );
                };
            };
            clearBase(from);
        };

        private func endRound() : SimulationResult {
            state.strikes := 0;
            state.outs := 0;

            ignore compiledHooks.roundEnd({
                prng = prng;
                state = state;
                context = ();
            });
            state.endRound();
            if (state.log.rounds.size() >= 18) {
                ignore compiledHooks.matchEnd({
                    prng = prng;
                    state = state;
                    context = ();
                });
                // End match if no more rounds
                return #endMatch(#noMoreRounds);
            };
            let newOffenseTeamId = switch (state.offenseTeamId) {
                case (#team1) #team2;
                case (#team2) #team1;
            };
            state.offenseTeamId := newOffenseTeamId;

            let atBat = getNextBatter();

            state.bases := {
                var atBat = atBat;
                var firstBase = null;
                var secondBase = null;
                var thirdBase = null;
            };
            state.addEvent(
                #teamSwap({
                    offenseTeamId = newOffenseTeamId;
                    atBatPlayerId = atBat;
                })
            );
            updateStats(
                atBat,
                func(stats : MutableState.MutablePlayerMatchStats) {
                    stats.battingStats.atBats += 1;
                },
            );

            ignore compiledHooks.roundStart({
                prng = prng;
                state = state;
                context = ();
            });
            #inProgress;
        };

        private func injurePlayer({ playerId : Nat32; injury : Player.Injury }) {
            let playerState = state.getPlayerState(playerId);
            playerState.condition := #injured(injury);
            state.addEvent(
                #injury({
                    playerId = playerId;
                    injury = injury;
                })
            );
        };

        private func score({ teamId : Team.TeamId; amount : Int }) {
            let team = state.getTeamState(teamId);
            team.score += amount;
            state.addEvent(#score({ teamId = teamId; amount = amount }));
        };

        private func removePlayerFromBase(playerId : PlayerId) : SimulationResult {
            let ?position = state.getOffensivePositionOfPlayer(playerId) else return #endMatch(#stateBroken(#playerExpectedOnField({ id = playerId; onOffense = false; description = "Player not on base, cannot remove from field" })));
            clearBase(position);
        };

        private func clearBase(base : Base.Base) : SimulationResult {
            switch (base) {
                case (#firstBase) state.bases.firstBase := null;
                case (#secondBase) state.bases.secondBase := null;
                case (#thirdBase) state.bases.thirdBase := null;
                case (#homeBase) {
                    let nextBatterId = getNextBatter();

                    updateStats(
                        nextBatterId,
                        func(stats : MutableState.MutablePlayerMatchStats) {
                            stats.battingStats.atBats += 1;
                        },
                    );
                    state.bases.atBat := nextBatterId;
                    state.addEvent(#newBatter({ playerId = nextBatterId }));
                };
            };
            #inProgress;
        };

    };
};


File: src/backend/stadium/StadiumActor.mo
import Player "../models/Player";
import Principal "mo:base/Principal";
import Trie "mo:base/Trie";
import Nat32 "mo:base/Nat32";
import Debug "mo:base/Debug";
import Types "../stadium/Types";
import Nat "mo:base/Nat";
import Buffer "mo:base/Buffer";
import Iter "mo:base/Iter";
import Timer "mo:base/Timer";
import MatchSimulator "MatchSimulator";
import Random "mo:base/Random";
import Error "mo:base/Error";
import PseudoRandomX "mo:random/PseudoRandomX";
import LeagueTypes "../league/Types";
import IterTools "mo:itertools/Iter";
import MatchAura "../models/MatchAura";
import Team "../models/Team";
import FieldPosition "../models/FieldPosition";
import Season "../models/Season";

actor : Types.StadiumActor {
    type PlayerState = Types.PlayerState;
    type FieldPosition = FieldPosition.FieldPosition;
    type MatchAura = MatchAura.MatchAura;
    type Prng = PseudoRandomX.PseudoRandomGenerator;
    type TeamWithId = Team.TeamWithId;

    type MatchGroupId = Nat;

    type CompletedMatchResult = {
        match : Season.CompletedMatch;
        matchStats : [Player.PlayerMatchStatsWithId];
    };

    stable var matchGroups = Trie.empty<Nat, Types.MatchGroup>();
    stable var leagueIdOrNull : ?Principal = null;

    system func postupgrade() {
        // Restart the timers for any match groups that were in progress
        for ((matchGroupId, matchGroup) in Trie.iter(matchGroups)) {
            resetTickTimerInternal<system>(matchGroupId);
        };
    };

    public shared ({ caller }) func setLeague(id : Principal) : async Types.SetLeagueResult {
        // TODO how to get the league id vs manual set
        // Set if the league is not set or if the caller is the league
        if (leagueIdOrNull == null or leagueIdOrNull == ?caller) {
            leagueIdOrNull := ?id;
            return #ok;
        };
        #notAuthorized;
    };

    public query func getMatchGroup(id : Nat) : async ?Types.MatchGroupWithId {
        switch (getMatchGroupOrNull(id)) {
            case (null) return null;
            case (?m) {
                ?{
                    m with
                    id = id;
                };
            };
        };
    };

    public query func getMatchGroups() : async [Types.MatchGroupWithId] {
        matchGroups
        |> Trie.iter(_)
        |> Iter.map(
            _,
            func(m : (Nat, Types.MatchGroup)) : Types.MatchGroupWithId = {
                m.1 with
                id = m.0;
            },
        )
        |> Iter.toArray(_);
    };

    public shared ({ caller }) func startMatchGroup(
        request : Types.StartMatchGroupRequest
    ) : async Types.StartMatchGroupResult {
        assertLeague(caller);

        let prng = PseudoRandomX.fromBlob(await Random.blob());
        let tickTimerId = startTickTimer<system>(request.id);

        let tickResults = Buffer.Buffer<Types.TickResult>(request.matches.size());
        label f for ((matchId, match) in IterTools.enumerate(Iter.fromArray(request.matches))) {

            let team1IsOffense = prng.nextCoin();
            let initState = MatchSimulator.initState(
                match.aura,
                match.team1,
                match.team2,
                team1IsOffense,
                prng,
            );
            tickResults.add({
                match = initState;
                status = #inProgress;
            });
        };
        if (tickResults.size() == 0) {
            return #noMatchesSpecified;
        };

        let matchGroup : Types.MatchGroupWithId = {
            id = request.id;
            matches = Buffer.toArray(tickResults);
            tickTimerId = tickTimerId;
            currentSeed = prng.getCurrentSeed();
        };
        addOrUpdateMatchGroup(matchGroup);
        #ok;
    };

    public shared ({ caller }) func cancelMatchGroup(
        request : Types.CancelMatchGroupRequest
    ) : async Types.CancelMatchGroupResult {
        assertLeague(caller);
        let matchGroupKey = buildMatchGroupKey(request.id);
        let (newMatchGroups, matchGroup) = Trie.remove(matchGroups, matchGroupKey, Nat.equal);
        switch (matchGroup) {
            case (null) return #matchGroupNotFound;
            case (?matchGroup) {
                matchGroups := newMatchGroups;
                Timer.cancelTimer(matchGroup.tickTimerId);
                #ok;
            };
        };
    };

    public shared func tickMatchGroup(matchGroupId : Nat) : async Types.TickMatchGroupResult {
        let ?leagueId = leagueIdOrNull else Debug.trap("League not set");
        let ?matchGroup = getMatchGroupOrNull(matchGroupId) else return #matchGroupNotFound;
        let prng = PseudoRandomX.LinearCongruentialGenerator(matchGroup.currentSeed);

        switch (tickMatches(prng, matchGroup.matches)) {
            case (#completed(completedTickResults)) {
                // Cancel tick timer before disposing of match group
                // NOTE: Should be canceled even if the onMatchGroupComplete fails, so it doesnt
                // just keep ticking. Can retrigger manually if needed after fixing the
                // issue

                let completedMatches = completedTickResults
                |> Iter.fromArray(_)
                |> Iter.map(
                    _,
                    func(tickResult : CompletedMatchResult) : Season.CompletedMatch = tickResult.match,
                )
                |> Iter.toArray(_);

                let playerStats = completedTickResults
                |> Iter.fromArray(_)
                |> Iter.map(
                    _,
                    func(tickResult : CompletedMatchResult) : Iter.Iter<Player.PlayerMatchStatsWithId> = Iter.fromArray(tickResult.matchStats),
                )
                |> IterTools.flatten<Player.PlayerMatchStatsWithId>(_)
                |> Iter.toArray(_);

                Timer.cancelTimer(matchGroup.tickTimerId);
                let leagueActor = actor (Principal.toText(leagueId)) : LeagueTypes.LeagueActor;
                let onCompleteRequest : LeagueTypes.OnMatchGroupCompleteRequest = {
                    id = matchGroupId;
                    matches = completedMatches;
                    playerStats = playerStats;
                };
                let result = try {
                    await leagueActor.onMatchGroupComplete(onCompleteRequest);
                } catch (err) {
                    #onCompleteCallbackError(Error.message(err));
                };

                let errorMessage = switch (result) {
                    case (#ok) {
                        // Remove match group if successfully passed info to the league
                        let matchGroupKey = buildMatchGroupKey(matchGroupId);
                        let (newMatchGroups, _) = Trie.remove(matchGroups, matchGroupKey, Nat.equal);
                        matchGroups := newMatchGroups;
                        return #completed;
                    };
                    case (#notAuthorized) "Failed: Not authorized to complete match group";
                    case (#matchGroupNotFound) "Failed: Match group not found - " # Nat.toText(matchGroupId);
                    case (#seedGenerationError(err)) "Failed: Seed generation error - " # err;
                    case (#seasonNotOpen) "Failed: Season not open";
                    case (#onCompleteCallbackError(err)) "Failed: On complete callback error - " # err;
                    case (#matchGroupNotInProgress) "Failed: Match group not in progress";
                };
                Debug.print("On Match Group Complete Result - " # errorMessage);
                // Stuck in a bad state. Can retry by a manual tick call
                #completed;
            };
            case (#inProgress(newMatches)) {
                addOrUpdateMatchGroup({
                    matchGroup with
                    id = matchGroupId;
                    matches = newMatches;
                    currentSeed = prng.getCurrentSeed();
                });

                #inProgress;
            };
        };
    };

    public shared func resetTickTimer(matchGroupId : Nat) : async Types.ResetTickTimerResult {
        resetTickTimerInternal<system>(matchGroupId);
        #ok;
    };

    private func resetTickTimerInternal<system>(matchGroupId : Nat) : () {
        let ?matchGroup = getMatchGroupOrNull(matchGroupId) else return;
        Timer.cancelTimer(matchGroup.tickTimerId);
        let newTickTimerId = startTickTimer<system>(matchGroupId);
        addOrUpdateMatchGroup({
            matchGroup with
            id = matchGroupId;
            tickTimerId = newTickTimerId;
        });
    };

    private func startTickTimer<system>(matchGroupId : Nat) : Timer.TimerId {
        Timer.recurringTimer<system>(
            #seconds(5),
            func() : async () {
                await tickMatchGroupCallback(matchGroupId);
            },
        );
    };

    private func addOrUpdateMatchGroup(newMatchGroup : Types.MatchGroupWithId) : () {
        let matchGroupKey = buildMatchGroupKey(newMatchGroup.id);
        let (newMatchGroups, _) = Trie.replace(matchGroups, matchGroupKey, Nat.equal, ?newMatchGroup);
        matchGroups := newMatchGroups;
    };

    private func tickMatchGroupCallback(matchGroupId : Nat) : async () {
        let message = try {
            switch (await tickMatchGroup(matchGroupId)) {
                case (#matchGroupNotFound) "Match Group not found";
                case (#onStartCallbackError(err)) "On start callback error: " # debug_show (err);
                case (#completed(_)) "Match Group completed";
                case (#inProgress(_)) return (); // Dont log normal tick
            };
        } catch (err) {
            "Failed to tick match group: " # Error.message(err);
        };
        Debug.print("Tick Match Group Callback Result - " # message);
    };

    private func tickMatches(prng : Prng, tickResults : [Types.TickResult]) : {
        #completed : [CompletedMatchResult];
        #inProgress : [Types.TickResult];
    } {
        let completedMatches = Buffer.Buffer<(Types.Match, Types.MatchStatusCompleted)>(tickResults.size());
        let updatedTickResults = Buffer.Buffer<Types.TickResult>(tickResults.size());
        for (tickResult in Iter.fromArray(tickResults)) {
            let updatedTickResult = switch (tickResult.status) {
                // Don't tick if completed
                case (#completed(c)) {
                    completedMatches.add((tickResult.match, c));
                    tickResult;
                };
                // Tick if still in progress
                case (#inProgress) MatchSimulator.tick(tickResult.match, prng);
            };
            updatedTickResults.add(updatedTickResult);
        };
        if (updatedTickResults.size() == completedMatches.size()) {
            // If all matches are complete, then complete the group
            let completedCompiledMatches = completedMatches.vals()
            |> Iter.map(
                _,
                func((match, status) : (Types.Match, Types.MatchStatusCompleted)) : CompletedMatchResult {
                    compileCompletedMatch(match, status);
                },
            )
            |> Iter.toArray(_);
            #completed(completedCompiledMatches);
        } else {
            #inProgress(Buffer.toArray(updatedTickResults));
        };
    };

    private func compileCompletedMatch(match : Types.Match, status : Types.MatchStatusCompleted) : CompletedMatchResult {
        let winner : Team.TeamIdOrTie = switch (status.reason) {
            case (#noMoreRounds) {
                if (match.team1.score > match.team2.score) {
                    #team1;
                } else if (match.team1.score == match.team2.score) {
                    #tie;
                } else {
                    #team2;
                };
            };
            case (#error(e)) #tie;
        };

        let playerStats = buildPlayerStats(match);

        {
            match : Season.CompletedMatch = {
                team1 = match.team1;
                team2 = match.team2;
                aura = match.aura;
                log = match.log;
                winner = winner;
                playerStats = playerStats;
            };
            matchStats = playerStats;
        };
    };

    private func buildPlayerStats(match : Types.Match) : [Player.PlayerMatchStatsWithId] {
        match.players.vals()
        |> Iter.map(
            _,
            func(player : Types.PlayerStateWithId) : Player.PlayerMatchStatsWithId {
                {
                    playerId = player.id;
                    battingStats = {
                        atBats = player.matchStats.battingStats.atBats;
                        hits = player.matchStats.battingStats.hits;
                        runs = player.matchStats.battingStats.runs;
                        strikeouts = player.matchStats.battingStats.strikeouts;
                        homeRuns = player.matchStats.battingStats.homeRuns;
                    };
                    catchingStats = {
                        successfulCatches = player.matchStats.catchingStats.successfulCatches;
                        missedCatches = player.matchStats.catchingStats.missedCatches;
                        throws = player.matchStats.catchingStats.throws;
                        throwOuts = player.matchStats.catchingStats.throwOuts;
                    };
                    pitchingStats = {
                        pitches = player.matchStats.pitchingStats.pitches;
                        strikes = player.matchStats.pitchingStats.strikes;
                        hits = player.matchStats.pitchingStats.hits;
                        runs = player.matchStats.pitchingStats.runs;
                        strikeouts = player.matchStats.pitchingStats.strikeouts;
                        homeRuns = player.matchStats.pitchingStats.homeRuns;
                    };
                    injuries = player.matchStats.injuries;
                };
            },
        )
        |> Iter.toArray(_);
    };

    private func getMatchGroupOrNull(matchGroupId : Nat) : ?Types.MatchGroup {
        let matchGroupKey = buildMatchGroupKey(matchGroupId);
        Trie.get(matchGroups, matchGroupKey, Nat.equal);
    };

    private func buildMatchGroupKey(matchGroupId : Nat) : {
        key : Nat;
        hash : Nat32;
    } {
        {
            hash = Nat32.fromNat(matchGroupId); // TODO better hash? shouldnt need more than 32 bits
            key = matchGroupId;
        };
    };

    private func assertLeague(caller : Principal) {
        let ?leagueId = leagueIdOrNull else Debug.trap("League not set");
        if (caller != leagueId) {
            Debug.trap("Only the league can schedule matches");
        };
    };
};


File: src/backend/stadium/StadiumUtil.mo
import Principal "mo:base/Principal";
import Trie "mo:base/Trie";
import TrieMap "mo:base/TrieMap";
import Hash "mo:base/Hash";
import Iter "mo:base/Iter";
module {

    public func trieToMap<T, K, N>(t : Trie.Trie<T, K>, equal : (T, T) -> Bool, hash : (T) -> Hash.Hash, mapFunc : (K) -> N) : TrieMap.TrieMap<T, N> {
        let entries = Trie.iter(t) |> Iter.map<(T, K), (T, N)>(_, func(x) { (x.0, mapFunc(x.1)) });
        TrieMap.fromEntries<T, N>(entries, equal, hash);
    };

    public func trieMapToTrie<T, K, N>(map : TrieMap.TrieMap<T, K>, equal : (T, T) -> Bool, hash : (T) -> Hash.Hash, mapFunc : (K) -> N) : Trie.Trie<T, N> {
        var trie = Trie.empty<T, N>();
        for (entry in map.entries()) {
            let key = {
                key = entry.0;
                hash = hash(entry.0);
            };
            let mappedValue = mapFunc(entry.1);
            let (newTrie, _) = Trie.put<T, N>(trie, key, equal, mappedValue);
            trie := newTrie;
        };
        trie;
    };
};


File: src/backend/stadium/Types.mo
import Principal "mo:base/Principal";
import Player "../models/Player";
import Nat "mo:base/Nat";
import MatchAura "../models/MatchAura";
import Base "../models/Base";
import Team "../models/Team";
import FieldPosition "../models/FieldPosition";
import Trait "../models/Trait";

module {
    type FieldPosition = FieldPosition.FieldPosition;
    type Base = Base.Base;
    type PlayerId = Player.PlayerId;

    public type StadiumActor = actor {
        setLeague : (id : Principal) -> async SetLeagueResult;
        getMatchGroup : query (id : Nat) -> async ?MatchGroupWithId;
        tickMatchGroup : (id : Nat) -> async TickMatchGroupResult;
        resetTickTimer : (matchGroupId : Nat) -> async ResetTickTimerResult;
        startMatchGroup : (request : StartMatchGroupRequest) -> async StartMatchGroupResult;
        cancelMatchGroup : (request : CancelMatchGroupRequest) -> async CancelMatchGroupResult;
    };

    public type CancelMatchGroupRequest = {
        id : Nat;
    };
    public type CancelMatchGroupResult = {
        #ok;
        #matchGroupNotFound;
    };

    public type SetLeagueResult = {
        #ok;
        #notAuthorized;
    };

    public type StadiumActorInfo = {};

    public type StadiumActorInfoWithId = StadiumActorInfo and {
        id : Principal;
    };

    public type CreateStadiumResult = {
        #ok : Principal;
        #stadiumCreationError : Text;
    };

    public type StartMatchGroupRequest = {
        id : Nat;
        matches : [StartMatchRequest];
    };

    public type Team = {
        id : Nat;
        name : Text;
        logoUrl : Text;
        color : (Nat8, Nat8, Nat8);
    };

    public type StartMatchTeam = Team and {
        positions : {
            firstBase : Player.Player;
            secondBase : Player.Player;
            thirdBase : Player.Player;
            shortStop : Player.Player;
            pitcher : Player.Player;
            leftField : Player.Player;
            centerField : Player.Player;
            rightField : Player.Player;
        };
    };

    public type StartMatchRequest = {
        team1 : StartMatchTeam;
        team2 : StartMatchTeam;
        aura : MatchAura.MatchAura;
    };

    public type StartMatchGroupError = {
        #noMatchesSpecified;
    };

    public type StartMatchError = {
        #notEnoughPlayers : Team.TeamIdOrBoth;
    };

    public type StartMatchGroupResult = StartMatchGroupError or {
        #ok;
    };

    public type RoundLog = {
        turns : [TurnLog];
    };

    public type TurnLog = {
        events : [Event];
    };

    public type HitLocation = FieldPosition.FieldPosition or {
        #stands;
    };

    public type Event = {
        #traitTrigger : {
            id : Trait.Trait;
            playerId : Player.PlayerId;
            description : Text;
        };
        #auraTrigger : {
            id : MatchAura.MatchAura;
            description : Text;
        };
        #pitch : {
            pitcherId : Player.PlayerId;
            roll : {
                value : Int;
                crit : Bool;
            };
        };
        #swing : {
            playerId : Player.PlayerId;
            roll : {
                value : Int;
                crit : Bool;
            };
            pitchRoll : {
                value : Int;
                crit : Bool;
            };
            outcome : {
                #foul;
                #strike;
                #hit : HitLocation;
            };
        };
        #catch_ : {
            playerId : Player.PlayerId;
            roll : {
                value : Int;
                crit : Bool;
            };
            difficulty : {
                value : Int;
                crit : Bool;
            };
        };
        #teamSwap : {
            offenseTeamId : Team.TeamId;
            atBatPlayerId : Player.PlayerId;
        };
        #injury : {
            playerId : Nat32;
            injury : Player.Injury;
        };
        #death : {
            playerId : Nat32;
        };
        #score : {
            teamId : Team.TeamId;
            amount : Int;
        };
        #newBatter : {
            playerId : Player.PlayerId;
        };
        #out : {
            playerId : Player.PlayerId;
            reason : OutReason;
        };
        #matchEnd : {
            reason : MatchEndReason;
        };
        #safeAtBase : {
            playerId : Player.PlayerId;
            base : Base.Base;
        };
        #throw_ : {
            from : Player.PlayerId;
            to : Player.PlayerId;
        };
        #hitByBall : {
            playerId : Player.PlayerId;
        };
    };

    public type MatchEndReason = {
        #noMoreRounds;
        #error : Text;
    };

    public type OutReason = {
        #ballCaught;
        #strikeout;
        #hitByBall;
    };

    public type MatchLog = {
        rounds : [RoundLog];
    };

    public type Match = {
        team1 : TeamState;
        team2 : TeamState;
        offenseTeamId : Team.TeamId;
        aura : MatchAura.MatchAura;
        players : [PlayerStateWithId];
        bases : BaseState;
        log : MatchLog;
        outs : Nat;
        strikes : Nat;
    };

    public type PlayerExpectedOnFieldError = {
        id : PlayerId;
        onOffense : Bool;
        description : Text;
    };

    public type BrokenStateError = {
        #playerNotFound : PlayerId;
        #playerExpectedOnField : PlayerExpectedOnFieldError;
    };

    public type TickResult = {
        match : Match;
        status : MatchStatus;
    };

    public type MatchStatus = {
        #inProgress;
        #completed : MatchStatusCompleted;
    };

    public type MatchStatusCompleted = {
        reason : MatchEndReason;
    };

    public type MatchGroup = {
        matches : [TickResult];
        tickTimerId : Nat;
        currentSeed : Nat32;
    };

    public type MatchGroupWithId = MatchGroup and {
        id : Nat;
    };

    public type ResetTickTimerResult = {
        #ok;
        #matchGroupNotFound;
    };

    public type PlayerState = {
        name : Text;
        teamId : Team.TeamId;
        condition : Player.PlayerCondition;
        skills : Player.Skills;
        matchStats : Player.PlayerMatchStats;
    };

    public type PlayerStateWithId = PlayerState and {
        id : PlayerId;
    };

    public type BaseState = {
        atBat : PlayerId;
        firstBase : ?PlayerId;
        secondBase : ?PlayerId;
        thirdBase : ?PlayerId;
    };

    public type TickMatchGroupResult = {
        #inProgress;
        #matchGroupNotFound;
        #onStartCallbackError : {
            #unknown : Text;
            #notScheduledYet;
            #alreadyStarted;
            #notAuthorized;
            #matchGroupNotFound;
        };
        #completed;
    };

    public type Player = {
        id : PlayerId;
        name : Text;
    };

    public type TeamState = Team and {
        score : Int;
        positions : FieldPosition.TeamPositions;
    };

};


File: src/backend/team/ScenarioHandler.mo
import Nat32 "mo:base/Nat32";
import Nat "mo:base/Nat";
import Principal "mo:base/Principal";
import Iter "mo:base/Iter";
import Text "mo:base/Text";
import HashMap "mo:base/HashMap";
import Debug "mo:base/Debug";
import Types "Types";

module {
    public type Vote = {
        userId : Principal;
        teamId : Nat;
        option : Nat;
        votingPower : Nat;
    };

    public type StableData = {
        scenarioId : Text;
        optionCount : Nat;
        votes : [Vote];
    };

    public class MultiHandler(data : [StableData]) {
        let iter = data.vals()
        |> Iter.map<StableData, (Text, Handler)>(
            _,
            func(d : StableData) : (Text, Handler) = (d.scenarioId, Handler(d)),
        );
        let handlers = HashMap.fromIter<Text, Handler>(iter, data.size(), Text.equal, Text.hash);

        public func getHandler(scenarioId : Text) : ?Handler {
            handlers.get(scenarioId);
        };

        public func add(scenarioId : Text, optionCount : Nat) {
            let data : StableData = {
                scenarioId = scenarioId;
                optionCount = optionCount;
                votes = [];
            };
            let null = handlers.get(scenarioId) else Debug.trap("Scenario already exists with id: " # scenarioId);
            handlers.put(scenarioId, Handler(data));
        };

        public func remove(scenarioId : Text) : { #ok; #notFound } {
            let ?_ = handlers.remove(scenarioId) else return #notFound;
            #ok;
        };

        public func toStableData() : [StableData] {
            handlers.entries()
            |> Iter.map<(Text, Handler), StableData>(
                _,
                func(e : (Text, Handler)) : StableData = e.1.toStableData(),
            )
            |> Iter.toArray(_);
        };
    };

    public class Handler(data : StableData) {
        let userVotes = data.votes.vals()
        |> Iter.map<Vote, (Principal, Vote)>(
            _,
            func(v : Vote) : (Principal, Vote) = (v.userId, v),
        );
        let votes = HashMap.fromIter<Principal, Vote>(userVotes, data.votes.size(), Principal.equal, Principal.hash);

        public func vote(
            voterId : Principal,
            teamId : Nat,
            votingPower : Nat,
            option : Nat,
        ) : { #ok; #invalidOption; #alreadyVoted } {

            let choiceExists = option < data.optionCount;
            if (not choiceExists) {
                return #invalidOption;
            };
            if (votes.get(voterId) != null) {
                return #alreadyVoted;
            };
            votes.put(
                voterId,
                {
                    userId = voterId;
                    teamId = teamId;
                    option = option;
                    votingPower = votingPower;
                },
            );
            #ok;
        };

        public func getVote(voterId : Principal) : ?Vote {
            votes.get(voterId);
        };

        public func calculateResults() : Types.ScenarioVotingResults {
            // TODO
            // if (caller != leagueId) {
            //     return #notAuthorized;
            // };
            // TeamId + Scenario Option Id -> Vote Count
            let optionVotes = HashMap.HashMap<(Nat, Nat), Nat>(
                data.optionCount,
                func(a : (Nat, Nat), b : (Nat, Nat)) = a == b,
                func(a : (Nat, Nat)) = Nat32.fromNat(a.0) + Nat32.fromNat(a.1), // TODO
            );
            for ((userId, vote) in votes.entries()) {
                let key = (vote.teamId, vote.option);
                let currentVotes = switch (optionVotes.get(key)) {
                    case (?v) v;
                    case (null) 0;
                };
                optionVotes.put(key, currentVotes + vote.votingPower);
            };
            var teamWinningOptions : HashMap.HashMap<Nat, (Nat, Nat)> = HashMap.HashMap(6, Nat.equal, Nat32.fromNat);
            for (((teamId, option), voteCount) in optionVotes.entries()) {
                switch (teamWinningOptions.get(teamId)) {
                    case (null) teamWinningOptions.put(teamId, (option, voteCount));
                    case (?currentWinner) {
                        if (currentWinner.1 < voteCount) {
                            teamWinningOptions.put(teamId, (option, voteCount));
                        };
                        // TODO what to do if there is a tie?
                    };
                };
            };
            let teamChoices = teamWinningOptions.entries()
            |> Iter.map(
                _,
                func((teamId, (option, _)) : (Nat, (Nat, Nat))) : {
                    teamId : Nat;
                    option : Nat;
                } = {
                    option = option;
                    teamId = teamId;
                },
            )
            |> Iter.toArray(_);
            {
                teamOptions = teamChoices;
            };
        };

        public func toStableData() : StableData {
            let voteData = votes.vals()
            |> Iter.toArray(_);
            {
                data with
                votes = voteData
            };
        };
    };
};


File: src/backend/team/TeamsActor.mo
import Principal "mo:base/Principal";
import Nat "mo:base/Nat";
import Debug "mo:base/Debug";
import Iter "mo:base/Iter";
import { ic } "mo:ic";
import Types "Types";
import TeamsHandler "TeamsHandler";
import ScenarioHandler "ScenarioHandler";
import UsersActor "canister:users";
import Dao "../Dao";

actor TeamsActor : Types.Actor {

  stable var stableData = {
    teams : [(Nat, TeamsHandler.StableData)] = [];
    scenarios : [ScenarioHandler.StableData] = [];
  };

  stable var leagueIdOrNull : ?Principal = null;

  var multiTeamHandler = TeamsHandler.MultiHandler<system>(stableData.teams);

  var scenarioMultiHandler = ScenarioHandler.MultiHandler(stableData.scenarios);

  system func preupgrade() {
    stableData := {
      teams = multiTeamHandler.toStableData();
      scenarios = scenarioMultiHandler.toStableData();
    };
  };

  system func postupgrade() {
    multiTeamHandler := TeamsHandler.MultiHandler<system>(stableData.teams);
  };

  public shared ({ caller }) func setLeague(id : Principal) : async Types.SetLeagueResult {
    // TODO how to get the league id vs manual set
    // Set if the league is not set or if the caller is the league
    if (leagueIdOrNull == null or leagueIdOrNull == ?caller) {
      leagueIdOrNull := ?id;
      return #ok;
    };
    #notAuthorized;
  };

  public shared ({ caller }) func createTeam(_ : Types.CreateTeamRequest) : async Types.CreateTeamResult {
    let leagueId = switch (leagueIdOrNull) {
      case (null) Debug.trap("League not set");
      case (?id) id;
    };

    if (leagueId != caller) {
      return #notAuthorized;
    };
    let (id, _) = multiTeamHandler.create(leagueId);
    #ok({
      id = id;
    });

  };

  public shared ({ caller }) func voteOnScenario(teamId : Nat, request : Types.VoteOnScenarioRequest) : async Types.VoteOnScenarioResult {
    let ?handler = scenarioMultiHandler.getHandler(request.scenarioId) else return #scenarioNotFound;
    switch (await UsersActor.get(caller)) {
      case (#ok(user)) {
        let ?team = user.team else return #notAuthorized;
        if (team.id != teamId) {
          return #notAuthorized;
        };
        let #owner(o) = team.kind else return #notAuthorized;
        handler.vote(caller, teamId, o.votingPower, request.option);
      };
      case (#notFound or #notAuthorized) #notAuthorized;
    };
  };

  public shared query ({ caller }) func getScenarioVote(request : Types.GetScenarioVoteRequest) : async Types.GetScenarioVoteResult {
    let ?handler = scenarioMultiHandler.getHandler(request.scenarioId) else return #scenarioNotFound;
    #ok(handler.getVote(caller));
  };

  public shared ({ caller }) func createProposal(teamId : Nat, request : Types.CreateProposalRequest) : async Types.CreateProposalResult {
    let members = switch (await UsersActor.getTeamOwners(#team(teamId))) {
      case (#ok(members)) members;
    };
    let isAMember = members
    |> Iter.fromArray(_)
    |> Iter.filter(
      _,
      func(member : Dao.Member) : Bool = member.id == caller,
    )
    |> _.next() != null;
    if (not isAMember) {
      return #notAuthorized;
    };
    let ?teamHandler = multiTeamHandler.get(teamId) else return #teamNotFound;
    teamHandler.createProposal<system>(caller, request, members);
  };

  public shared query func getProposal(teamId : Nat, id : Nat) : async Types.GetProposalResult {
    let ?teamHandler = multiTeamHandler.get(teamId) else return #teamNotFound;
    switch (teamHandler.getProposal(id)) {
      case (null) #proposalNotFound;
      case (?proposal) #ok(proposal);
    };
  };

  public shared query func getProposals(teamId : Nat, count : Nat, offset : Nat) : async Types.GetProposalsResult {
    let ?teamHandler = multiTeamHandler.get(teamId) else return #teamNotFound;
    #ok(teamHandler.getProposals(count, offset));
  };

  public shared ({ caller }) func voteOnProposal(teamId : Nat, request : Types.VoteOnProposalRequest) : async Types.VoteOnProposalResult {
    let ?teamHandler = multiTeamHandler.get(teamId) else return #teamNotFound;
    await* teamHandler.voteOnProposal(caller, request);
  };

  public shared ({ caller }) func getScenarioVotingResults(request : Types.GetScenarioVotingResultsRequest) : async Types.GetScenarioVotingResultsResult {
    let leagueId = switch (leagueIdOrNull) {
      case (null) Debug.trap("League not set");
      case (?id) id;
    };
    if (caller != leagueId) {
      return #notAuthorized;
    };
    let ?handler = scenarioMultiHandler.getHandler(request.scenarioId) else return #scenarioNotFound;
    let results = handler.calculateResults();
    #ok(results);
  };

  public shared ({ caller }) func onNewScenario(request : Types.OnNewScenarioRequest) : async Types.OnNewScenarioResult {
    Debug.print("onNewScenario called: " # debug_show (request));
    let leagueId = switch (leagueIdOrNull) {
      case (null) Debug.trap("League not set");
      case (?id) id;
    };
    if (caller != leagueId) {
      return #notAuthorized;
    };
    scenarioMultiHandler.add(request.scenarioId, request.optionCount);
    #ok;
  };

  public shared ({ caller }) func onScenarioVoteComplete(request : Types.OnScenarioVoteCompleteRequest) : async Types.OnScenarioVoteCompleteResult {
    let leagueId = switch (leagueIdOrNull) {
      case (null) Debug.trap("League not set");
      case (?id) id;
    };
    if (caller != leagueId) {
      return #notAuthorized;
    };
    switch (scenarioMultiHandler.remove(request.scenarioId)) {
      case (#ok) #ok;
      case (#notFound) #scenarioNotFound;
    };
  };

  public shared ({ caller }) func onSeasonEnd() : async Types.OnSeasonEndResult {
    let leagueId = switch (leagueIdOrNull) {
      case (null) Debug.trap("League not set");
      case (?id) id;
    };
    if (caller != leagueId) {
      return #notAuthorized;
    };
    // TODO
    #ok;
  };

  public shared ({ caller }) func getCycles() : async Types.GetCyclesResult {
    let leagueId = switch (leagueIdOrNull) {
      case (null) Debug.trap("League not set");
      case (?id) id;
    };
    if (caller != leagueId) {
      return #notAuthorized;
    };
    let canisterStatus = await ic.canister_status({
      canister_id = Principal.fromActor(TeamsActor);
    });
    return #ok(canisterStatus.cycles);
  };
};


File: src/backend/team/TeamsHandler.mo
import Dao "../Dao";
import Types "Types";
import LeagueTypes "../league/Types";
import Principal "mo:base/Principal";
import Debug "mo:base/Debug";
import Iter "mo:base/Iter";
import HashMap "mo:base/HashMap";
import Nat "mo:base/Nat";
import Nat32 "mo:base/Nat32";
import CommonTypes "../Types";
import PlayersActor "canister:players";

module {

    public type StableData = {
        leagueId : Principal;
        teamId : Nat;
        dao : Dao.StableData<Types.ProposalContent>;
    };

    public class MultiHandler<system>(teams : [(Nat, StableData)]) {
        let handlers : HashMap.HashMap<Nat, Handler> = HashMap.HashMap<Nat, Handler>(teams.size(), Nat.equal, Nat32.fromNat);

        for ((id, stableData) in Iter.fromArray(teams)) {
            let handler = Handler(stableData);
            handler.onInit<system>();
            handlers.put(id, handler);
        };

        var nextTeamId = teams.size(); // TODO change to check for the largest team id in the list

        public func toStableData() : [(Nat, StableData)] {
            handlers.entries()
            |> Iter.map<(Nat, Handler), (Nat, StableData)>(
                _,
                func((teamId, handler) : (Nat, Handler)) : (Nat, StableData) {
                    (teamId, handler.toStableData());
                },
            )
            |> Iter.toArray(_);
        };

        public func get(teamId : Nat) : ?Handler {
            handlers.get(teamId);
        };

        public func create(leagueId : Principal) : (Nat, Handler) {
            let teamId = nextTeamId;
            nextTeamId += 1;
            let handler = Handler({
                leagueId = leagueId;
                teamId = teamId;
                dao = {
                    proposals = [];
                    proposalDuration = #days(3);
                    votingThreshold = #percent({
                        percent = 50;
                        quorum = ?20;
                    });
                };
                scenarioVoting = [];
            });
            handlers.put(teamId, handler);
            (teamId, handler);
        };
    };

    public class Handler(stableData : StableData) {
        let leagueId = stableData.leagueId;
        let teamId = stableData.teamId;

        func onExecute(proposal : Dao.Proposal<Types.ProposalContent>) : async* Dao.OnExecuteResult {
            switch (proposal.content) {
                case (#trainPlayer(trainPlayer)) {
                    // TODO
                    Debug.print("Training player: " # debug_show (trainPlayer));
                    #ok;
                };
                case (#changeName(n)) {
                    let leagueActor = actor (Principal.toText(leagueId)) : LeagueTypes.LeagueActor;
                    let result = await leagueActor.createProposal({
                        content = #changeTeamName({
                            teamId = teamId;
                            name = n.name;
                        });
                    });
                    switch (result) {
                        case (#ok(_)) #ok;
                        case (#notAuthorized) #err("Not authorized to create change name proposal in league DAO");
                    };
                };
                case (#swapPlayerPositions(swap)) {
                    switch (await PlayersActor.swapTeamPositions(teamId, swap.position1, swap.position2)) {
                        case (#ok) #ok;
                        case (#notAuthorized) #err("Not authorized to swap player positions in players actor");
                    };
                };
            };
        };

        func onReject(proposal : Dao.Proposal<Types.ProposalContent>) : async* () {
            Debug.print("Rejected proposal: " # debug_show (proposal));
        };
        var dao = Dao.Dao<Types.ProposalContent>(stableData.dao, onExecute, onReject);

        public func onInit<system>() {
            dao.resetEndTimers<system>();
        };

        public func toStableData() : StableData {
            {
                leagueId = leagueId;
                teamId = teamId;
                dao = dao.toStableData();
            };
        };

        public func getProposal(id : Nat) : ?Dao.Proposal<Types.ProposalContent> {
            dao.getProposal(id);
        };

        public func getProposals(count : Nat, offset : Nat) : CommonTypes.PagedResult<Dao.Proposal<Types.ProposalContent>> {
            dao.getProposals(count, offset);
        };

        public func voteOnProposal(caller : Principal, request : Types.VoteOnProposalRequest) : async* Types.VoteOnProposalResult {
            await* dao.vote(request.proposalId, caller, request.vote);
        };

        public func createProposal<system>(caller : Principal, request : Types.CreateProposalRequest, members : [Dao.Member]) : Types.CreateProposalResult {
            dao.createProposal<system>(caller, request.content, members);
        };

    };
};


File: src/backend/team/Types.mo
import Principal "mo:base/Principal";
import Dao "../Dao";
import Skill "../models/Skill";
import CommonTypes "../Types";
import FieldPosition "../models/FieldPosition";

module {

    public type Actor = actor {
        setLeague : (id : Principal) -> async SetLeagueResult;
        getScenarioVote : query (request : GetScenarioVoteRequest) -> async GetScenarioVoteResult;
        voteOnScenario : (teamId : Nat, request : VoteOnScenarioRequest) -> async VoteOnScenarioResult;
        createProposal : (teamId : Nat, request : CreateProposalRequest) -> async CreateProposalResult;
        getProposal : query (teamId : Nat, id : Nat) -> async GetProposalResult;
        getProposals : query (teamId : Nat, count : Nat, offset : Nat) -> async GetProposalsResult;
        voteOnProposal : (teamId : Nat, request : VoteOnProposalRequest) -> async VoteOnProposalResult;
        getScenarioVotingResults : (request : GetScenarioVotingResultsRequest) -> async GetScenarioVotingResultsResult;
        onNewScenario : (request : OnNewScenarioRequest) -> async OnNewScenarioResult;
        onScenarioVoteComplete : (request : OnScenarioVoteCompleteRequest) -> async OnScenarioVoteCompleteResult;
        onSeasonEnd() : async OnSeasonEndResult;
    };

    public type GetProposalResult = {
        #ok : Proposal;
        #proposalNotFound;
        #teamNotFound;
    };

    public type GetProposalsResult = {
        #ok : CommonTypes.PagedResult<Proposal>;
        #teamNotFound;
    };

    public type VoteOnProposalRequest = {
        proposalId : Nat;
        vote : Bool;
    };

    public type VoteOnProposalResult = {
        #ok;
        #notAuthorized;
        #proposalNotFound;
        #alreadyVoted;
        #votingClosed;
        #teamNotFound;
    };

    public type Proposal = Dao.Proposal<ProposalContent>;

    public type ProposalContent = {
        #changeName : {
            name : Text;
        };
        #trainPlayer : {
            playerId : Nat32;
            skill : Skill.Skill;
        };
        #swapPlayerPositions : {
            position1 : FieldPosition.FieldPosition;
            position2 : FieldPosition.FieldPosition;
        };
    };

    public type CreateProposalRequest = {
        content : ProposalContent;
    };

    public type CreateProposalResult = {
        #ok : Nat;
        #notAuthorized;
        #teamNotFound;
    };

    public type OnScenarioVoteCompleteRequest = {
        scenarioId : Text;
    };

    public type OnScenarioVoteCompleteResult = {
        #ok;
        #scenarioNotFound;
        #notAuthorized;
    };

    public type OnNewScenarioRequest = {
        scenarioId : Text;
        optionCount : Nat;
    };

    public type OnNewScenarioResult = {
        #ok;
        #notAuthorized;
    };

    public type OnSeasonEndResult = {
        #ok;
        #notAuthorized;
    };

    public type SetLeagueResult = {
        #ok;
        #notAuthorized;
    };

    public type CreateTeamRequest = {

    };

    public type CreateTeamResult = {
        #ok : {
            id : Nat;
        };
        #notAuthorized;
    };

    public type MatchVoteResult = {
        votes : [Nat];
    };

    public type ScenarioVoteResult = {
        option : Nat;
    };

    public type GetScenarioVoteRequest = {
        scenarioId : Text;
    };

    public type GetScenarioVoteResult = {
        #ok : ?{
            option : Nat;
            votingPower : Nat;
        };
        #scenarioNotFound;
        #teamNotFound;
    };

    public type GetScenarioVotingResultsRequest = {
        scenarioId : Text;
    };

    public type ScenarioTeamVotingResult = {
        teamId : Nat;
        option : Nat;
    };

    public type ScenarioVotingResults = {
        teamOptions : [ScenarioTeamVotingResult];
    };

    public type GetScenarioVotingResultsResult = {
        #ok : ScenarioVotingResults;
        #notAuthorized;
        #scenarioNotFound;
    };

    public type GetCyclesResult = {
        #ok : Nat;
        #notAuthorized;
    };

    public type VoteOnScenarioRequest = {
        scenarioId : Text;
        option : Nat;
    };

    public type VoteOnScenarioResult = {
        #ok;
        #notAuthorized;
        #scenarioNotFound;
        #votingNotOpen;
        #teamNotInScenario;
        #alreadyVoted;
        #seasonStatusFetchError : Text;
        #invalidOption;
        #teamNotFound;
    };
};


File: src/backend/users/Types.mo
import Principal "mo:base/Principal";
import Nat "mo:base/Nat";

module {

    public type Actor = actor {
        get : query (userId : Principal) -> async GetUserResult;
        getStats : query () -> async GetStatsResult;
        getTeamOwners : query (request : GetTeamOwnersRequest) -> async GetTeamOwnersResult;
        setFavoriteTeam : (userId : Principal, teamId : Nat) -> async SetUserFavoriteTeamResult;
        addTeamOwner : (request : AddTeamOwnerRequest) -> async AddTeamOwnerResult;
        awardPoints : (awards : [AwardPointsRequest]) -> async AwardPointsResult;
        onSeasonEnd : () -> async OnSeasonEndResult;
    };

    public type GetStatsResult = {
        #ok : UserStats;
    };

    public type UserStats = {
        totalPoints : Int;
        userCount : Nat;
        teamOwnerCount : Nat;
        teams : [TeamStats];
    };

    public type TeamStats = {
        id : Nat;
        totalPoints : Int;
        userCount : Nat;
        ownerCount : Nat;
    };

    public type OnSeasonEndResult = {
        #ok;
        #notAuthorized;
    };

    public type GetTeamOwnersRequest = {
        #team : Nat;
        #all;
    };

    public type GetTeamOwnersResult = {
        #ok : [UserVotingInfo];
    };

    public type TeamAssociationKind = {
        #fan;
        #owner : {
            votingPower : Nat;
        };
    };

    public type User = {
        // TODO team association be in the season?
        id : Principal;
        team : ?{
            id : Nat;
            kind : TeamAssociationKind;
        };
        points : Int;
    };

    public type UserVotingInfo = {
        id : Principal;
        votingPower : Nat;
    };

    public type AddTeamOwnerRequest = {
        userId : Principal;
        teamId : Nat;
        votingPower : Nat;
    };

    public type AddTeamOwnerResult = {
        #ok;
        #onOtherTeam : Nat;
        #teamNotFound;
        #notAuthorized;
    };

    public type GetUserResult = {
        #ok : User;
        #notFound;
        #notAuthorized;
    };

    public type AwardPointsRequest = {
        userId : Principal;
        points : Int;
    };

    public type AwardPointsResult = {
        #ok;
        #notAuthorized;
    };

    public type SetUserFavoriteTeamResult = {
        #ok;
        #identityRequired;
        #teamNotFound;
        #notAuthorized;
        #alreadySet;
    };
};


File: src/backend/users/UsersActor.mo
import Trie "mo:base/Trie";
import Principal "mo:base/Principal";
import Iter "mo:base/Iter";
import Hash "mo:base/Hash";
import HashMap "mo:base/HashMap";
import Nat "mo:base/Nat";
import Nat32 "mo:base/Nat32";
import IterTools "mo:itertools/Iter";
import Types "./Types";
// import LeagueActor "canister:league"; TODO

actor : Types.Actor {

    stable var users : Trie.Trie<Principal, Types.User> = Trie.empty();

    public shared query ({ caller }) func get(userId : Principal) : async Types.GetUserResult {
        if (caller != userId and not isLeague(caller)) {
            return #notAuthorized;
        };
        let ?user = Trie.get(users, buildPrincipalKey(userId), Principal.equal) else return #notFound;
        #ok(user);
    };

    public shared query func getStats() : async Types.GetStatsResult {
        let leagueStats = {
            var totalPoints : Int = 0;
            var userCount = 0;
            var teamOwnerCount = 0;
        };
        let teamStats = HashMap.HashMap<Nat, Types.TeamStats>(6, Nat.equal, Nat32.fromNat);
        for ((userId, user) in Trie.iter(users)) {
            switch (user.team) {
                case (?team) {
                    let stats : Types.TeamStats = switch (teamStats.get(team.id)) {
                        case (?stats) stats;
                        case (null) {
                            {
                                id = team.id;
                                totalPoints = 0;
                                userCount = 0;
                                ownerCount = 0;
                            };
                        };
                    };
                    let isOwner = switch (team.kind) {
                        case (#owner(_)) true;
                        case (#fan) false;
                    };
                    let newStats : Types.TeamStats = {
                        id = team.id;
                        totalPoints = stats.totalPoints + user.points;
                        userCount = stats.userCount + 1;
                        ownerCount = stats.ownerCount + (if (isOwner) 1 else 0);
                    };
                    leagueStats.totalPoints += user.points;
                    leagueStats.userCount += 1;
                    leagueStats.teamOwnerCount += (if (isOwner) 1 else 0);

                    teamStats.put(team.id, newStats);
                };
                case (null) ();
            };
        };
        #ok({
            totalPoints = leagueStats.totalPoints;
            userCount = leagueStats.userCount;
            teamOwnerCount = leagueStats.teamOwnerCount;
            teams = Iter.toArray<Types.TeamStats>(teamStats.vals());
        });
    };

    public shared query func getTeamOwners(request : Types.GetTeamOwnersRequest) : async Types.GetTeamOwnersResult {
        let owners = Trie.iter(users)
        |> IterTools.mapFilter(
            _,
            func((userId, user) : (Principal, Types.User)) : ?Types.UserVotingInfo {
                let ?team = user.team else return null;
                switch (request) {
                    case (#team(teamId)) {
                        // Filter to only the team we want
                        if (team.id != teamId) {
                            return null;
                        };
                    };
                    case (#all) (); // No filter
                };
                let #owner(o) = team.kind else return null;
                ?{
                    id = userId;
                    votingPower = o.votingPower;
                };
            },
        )
        |> Iter.toArray(_);
        #ok(owners);
    };

    public shared ({ caller }) func setFavoriteTeam(userId : Principal, teamId : Nat) : async Types.SetUserFavoriteTeamResult {
        if (Principal.isAnonymous(userId)) {
            return #identityRequired;
        };
        if (caller != userId and not isLeague(caller)) {
            return #notAuthorized;
        };
        let userInfo = getUserInfoInternal(userId);
        switch (userInfo.team) {
            case (?team) {
                return #alreadySet;
            };
            case (null) {
                let teamExists = true; // TODO get all team ids and check if teamId is in there
                if (not teamExists) {
                    return #teamNotFound;
                };
                updateUser(
                    userId,
                    func(user : Types.User) : Types.User = {
                        user with
                        team = ?{
                            id = teamId;
                            kind = #fan;
                        };
                    },
                );
            };
        };
        #ok;
    };

    public shared ({ caller }) func addTeamOwner(request : Types.AddTeamOwnerRequest) : async Types.AddTeamOwnerResult {
        if (not isLeague(caller)) {
            return #notAuthorized;
        };
        let userInfo = getUserInfoInternal(request.userId);
        switch (userInfo.team) {
            case (?team) {
                if (team.id != request.teamId) {
                    return #onOtherTeam(team.id);
                };
            };
            case (null) {
                let teamExists = true; // TODO get all team ids and check if teamId is in there
                if (not teamExists) {
                    return #teamNotFound;
                };
            };
        };
        updateUser(
            request.userId,
            func(user : Types.User) : Types.User = {
                user with
                team = ?{
                    id = request.teamId;
                    kind = #owner({ votingPower = request.votingPower });
                };
            },
        );
        #ok;
    };

    // TODO change to BoomDAO or ledger
    public shared ({ caller }) func awardPoints(awards : [Types.AwardPointsRequest]) : async Types.AwardPointsResult {
        if (not isLeague(caller)) {
            return #notAuthorized;
        };
        for (award in Iter.fromArray(awards)) {
            updateUser(
                award.userId,
                func(user : Types.User) : Types.User = {
                    user with
                    points = user.points + award.points;
                },
            );
        };
        #ok;
    };

    public shared ({ caller }) func onSeasonEnd() : async Types.OnSeasonEndResult {
        if (not isLeague(caller)) {
            return #notAuthorized;
        };
        users := Trie.empty();
        #ok;
    };

    private func updateUser(userId : Principal, f : (Types.User) -> Types.User) {
        let userInfo = getUserInfoInternal(userId);
        let newUserInfo = f(userInfo);
        let key = buildPrincipalKey(userId);
        let (newUsers, _) = Trie.put(users, key, Principal.equal, newUserInfo);
        users := newUsers;
    };

    private func getUserInfoInternal(userId : Principal) : Types.User {
        switch (Trie.get(users, buildPrincipalKey(userId), Principal.equal)) {
            case (?userInfo) userInfo;
            case (null) {
                {
                    id = userId;
                    team = null;
                    points = 0;
                };
            };
        };
    };

    private func buildPrincipalKey(id : Principal) : {
        key : Principal;
        hash : Hash.Hash;
    } {
        { key = id; hash = Principal.hash(id) };
    };

    private func isLeague(_ : Principal) : Bool {
        // TODO
        // return caller == Principal.fromActor(LeagueActor);
        return true;
    };
};


